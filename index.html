<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Corrida Arcade Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            transition: opacity 0.5s;
        }

        .hidden {
            display: none;
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffea;
            color: #00ffea;
            letter-spacing: 3px;
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 30px;
            color: #ffcc00;
        }

        button {
            background: #ff3366;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        button:hover {
            background: #ff0066;
            transform: scale(1.05);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        .upgrade-option {
            background: rgba(30, 30, 60, 0.8);
            padding: 15px;
            margin: 10px;
            border-radius: 10px;
            width: 300px;
            text-align: center;
            border: 2px solid #00ffea;
        }

        .upgrade-option h3 {
            color: #ffcc00;
            margin-bottom: 10px;
        }

        .upgrade-option p {
            margin-bottom: 10px;
        }

        .dashboard {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 220px;
            height: 220px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            border: 3px solid #00ffea;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }

        .rpm-gauge {
            position: relative;
            width: 180px;
            height: 180px;
        }

        .rpm-needle {
            position: absolute;
            width: 3px;
            height: 85px;
            background: #ff3366;
            top: 50%;
            left: 50%;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(-135deg);
            transition: transform 0.1s;
            z-index: 2;
        }

        .rpm-tick {
            position: absolute;
            width: 2px;
            height: 10px;
            background: #fff;
            top: 0;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%);
        }

        .rpm-label {
            position: absolute;
            color: #fff;
            font-size: 12px;
            transform: translate(-50%, -50%);
        }

        .speed-display {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #ffcc00;
            z-index: 3;
        }

        .gear-display {
            position: absolute;
            top: 75%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8rem;
            color: #ff3366;
            z-index: 3;
        }

        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffea;
            z-index: 5;
            font-size: 1.2rem;
            color: #00ffea;
        }

        .player-name {
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 4;
        }

        #mobileControls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 5;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px;
            color: white;
            font-size: 1.5rem;
            border: 2px solid #00ffea;
            user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            background: rgba(0, 255, 234, 0.3);
        }

        .gear-controls {
            flex-direction: row;
        }

        .gear-btn {
            width: 60px;
            height: 60px;
            margin: 5px;
            background: rgba(255, 51, 102, 0.7);
        }

        .gear-display {
            background: rgba(30, 30, 60, 0.8);
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffcc00;
            border: 2px solid #00ffea;
            margin-top: 10px;
        }

        .dpad-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .dpad-row {
            display: flex;
        }

        .dpad-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #00ffea;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            margin: 5px;
        }

        #instructions {
            max-width: 600px;
            text-align: center;
            margin: 20px;
            line-height: 1.6;
        }

        #instructions p {
            margin: 10px 0;
            color: #aaa;
        }

        .highlight {
            color: #ffcc00;
            font-weight: bold;
        }

        .pulse {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #playerNameInput, #roomInput {
            padding: 12px;
            margin: 10px;
            font-size: 1rem;
            border-radius: 30px;
            border: 2px solid #00ffea;
            background: rgba(30, 30, 60, 0.8);
            color: white;
            width: 300px;
            text-align: center;
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
            flex-direction: column;
        }

        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #endGameScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 300;
            display: none;
            width: 80%;
            max-width: 500px;
        }

        .car-selector {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .car-option {
            margin: 0 15px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 10px;
            transition: all 0.3s;
        }

        .car-option:hover, .car-option.selected {
            border-color: #00ffea;
            transform: scale(1.05);
        }

        .car-option img {
            width: 100px;
            height: 60px;
            object-fit: cover;
            border-radius: 5px;
        }

        .bet-amount {
            margin: 15px 0;
            font-size: 1.2rem;
        }

        .bet-controls {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }

        .bet-btn {
            width: 40px;
            height: 40px;
            margin: 0 10px;
            padding: 0;
            border-radius: 50%;
            font-size: 1.5rem;
            line-height: 1;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            #status {
                font-size: 0.9rem;
                padding: 10px;
            }
            .dashboard {
                width: 150px;
                height: 150px;
                bottom: 100px;
            }
            .rpm-gauge {
                width: 120px;
                height: 120px;
            }
            .rpm-needle {
                height: 60px;
            }
            .speed-display {
                font-size: 1.4rem;
            }
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.2rem;
            }
            .dpad-btn {
                width: 50px;
                height: 50px;
            }
            #playerNameInput, #roomInput {
                width: 250px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen" class="screen">
            <h1>CORRIDA ARCADE</h1>
            <h2>MULTIPLAYER 3D</h2>
            <div id="instructions">
                <p>Controles <span class="highlight">DESKTOP</span>: Direção A/D | Acelerar: Espaço | Marchas: W/S</p>
                <p>Controles <span class="highlight">MOBILE</span>: Use os controles na parte inferior da tela</p>
                <p>Objetivo: Complete 3 voltas na pista antes do seu oponente!</p>
            </div>
            <input type="text" id="playerNameInput" placeholder="Digite seu nome" maxlength="15">
            <input type="text" id="roomInput" placeholder="Digite o ID da sala ou clique em Gerar ID">
            <div>
                <button id="generateIdButton" class="pulse">GERAR ID</button>
                <button id="copyIdButton" class="pulse">COPIAR ID</button>
            </div>
            <button id="startButton" class="pulse">INICIAR CORRIDA</button>
            <button id="offlineButton" class="pulse">JOGAR OFFLINE</button>
        </div>

        <div id="upgradeScreen" class="screen hidden">
            <h1>LOJA DE UPGRADES</h1>
            <h2 id="moneyDisplay">Dinheiro: $300</h2>
            <div class="upgrade-option">
                <h3>MOTOR TURBO</h3>
                <p>Aumenta o torque máximo em 20%</p>
                <p>Custo: $100</p>
                <button class="buy-button" data-upgrade="torque">COMPRAR</button>
            </div>
            <div class="upgrade-option">
                <h3>AERODINÂMICA</h3>
                <p>Aumenta a velocidade máxima em 15%</p>
                <p>Custo: $150</p>
                <button class="buy-button" data-upgrade="speed">COMPRAR</button>
            </div>
            <div class="upgrade-option">
                <h3>TRANSMISSÃO ESPORTIVA</h3>
                <p>Amplia a faixa útil de cada marcha</p>
                <p>Custo: $200</p>
                <button class="buy-button" data-upgrade="gears">COMPRAR</button>
            </div>
            <div class="bet-amount">
                Aposta: $<span id="betValue">0</span>
            </div>
            <div class="bet-controls">
                <button class="bet-btn" id="betDecrease">-</button>
                <button class="bet-btn" id="betIncrease">+</button>
            </div>
            <button id="raceButton">INICIAR CORRIDA</button>
        </div>

        <div id="gameScreen" class="screen hidden">
            <canvas id="gameCanvas"></canvas>
            
            <div class="dashboard">
                <div class="player-name" id="playerNameTag">Player</div>
                <div class="rpm-gauge">
                    <div class="rpm-needle" id="rpmNeedle"></div>
                    <div class="speed-display" id="speedDisplay">0</div>
                    <div class="gear-display" id="gearDisplay">N</div>
                </div>
            </div>
            
            <div id="status">Pronto para conectar...</div>
            
            <div id="mobileControls">
                <div class="control-group">
                    <div class="control-btn" id="gearUpBtn">↑</div>
                    <div class="control-btn" id="gearDownBtn">↓</div>
                </div>
                
                <div class="control-group">
                    <div class="dpad-container">
                        <div class="dpad-row">
                            <div class="dpad-btn" id="dpadLeft">←</div>
                            <div class="dpad-btn" id="dpadRight">→</div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-btn accelerate-btn" id="accelerateBtn">A</div>
                    <div class="control-btn brake-btn" id="brakeBtn">F</div>
                </div>
            </div>
        </div>

        <div id="loadingOverlay" style="display: none;">
            <div class="loader"></div>
            <div id="loadingText">Conectando...</div>
        </div>

        <div id="endGameScreen">
            <h2 id="endGameMessage"></h2>
            <div id="raceResults"></div>
            <button id="rematchBtn">PRÓXIMA CORRIDA</button>
            <button id="exitBtn">SAIR</button>
        </div>
    </div>

    <!-- Car models -->
    <script id="carModels">
        // Car Model 1: Basic Sports Car
        const carModel1 = {
            name: "Esportivo Básico",
            color: 0x3366ff,
            acceleration: 0.15,
            maxSpeed: 220,
            torqueMultiplier: 1.0,
            createModel: function() {
                const carGroup = new THREE.Group();

                // Car body
                const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: this.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;
                carGroup.add(body);

                // Hood
                const hoodGeometry = new THREE.BoxGeometry(2.8, 0.5, 2);
                const hoodMaterial = new THREE.MeshStandardMaterial({ color: 0x2244cc });
                const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
                hood.position.set(0, 0.75, 1);
                hood.castShadow = true;
                carGroup.add(hood);

                // Wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16);
                wheelGeometry.rotateZ(Math.PI / 2);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });

                const wheelPositions = [
                    { x: -1.5, y: 0.5, z: 2 },
                    { x: 1.5, y: 0.5, z: 2 },
                    { x: -1.5, y: 0.5, z: -2 },
                    { x: 1.5, y: 0.5, z: -2 }
                ];

                this.wheels = [];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(pos.x, pos.y, pos.z);
                    wheel.castShadow = true;
                    carGroup.add(wheel);
                    this.wheels.push(wheel);
                });

                // Lights
                const lightGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const lightMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00 
                });

                const frontLight1 = new THREE.Mesh(lightGeometry, lightMaterial);
                frontLight1.position.set(-0.8, 0.7, 2.5);
                carGroup.add(frontLight1);

                const frontLight2 = new THREE.Mesh(lightGeometry, lightMaterial);
                frontLight2.position.set(0.8, 0.7, 2.5);
                carGroup.add(frontLight2);

                return carGroup;
            }
        };

        // Car Model 2: Muscle Car
        const carModel2 = {
            name: "Muscle Car",
            color: 0xff5500,
            acceleration: 0.18,
            maxSpeed: 200,
            torqueMultiplier: 1.2,
            createModel: function() {
                const carGroup = new THREE.Group();

                // Car body
                const bodyGeometry = new THREE.BoxGeometry(3.2, 1.1, 5.5);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: this.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;
                carGroup.add(body);

                // Hood
                const hoodGeometry = new THREE.BoxGeometry(3, 0.6, 2.2);
                const hoodMaterial = new THREE.MeshStandardMaterial({ color: 0xcc4400 });
                const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
                hood.position.set(0, 0.8, 1.2);
                hood.castShadow = true;
                carGroup.add(hood);

                // Wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.55, 0.55, 0.9, 16);
                wheelGeometry.rotateZ(Math.PI / 2);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });

                const wheelPositions = [
                    { x: -1.6, y: 0.5, z: 2.2 },
                    { x: 1.6, y: 0.5, z: 2.2 },
                    { x: -1.6, y: 0.5, z: -2.2 },
                    { x: 1.6, y: 0.5, z: -2.2 }
                ];

                this.wheels = [];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(pos.x, pos.y, pos.z);
                    wheel.castShadow = true;
                    carGroup.add(wheel);
                    this.wheels.push(wheel);
                });

                // Exhaust pipes
                const exhaustGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 8);
                const exhaustMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                
                const exhaust1 = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                exhaust1.position.set(-0.6, 0.4, -2.6);
                exhaust1.rotation.x = Math.PI / 2;
                carGroup.add(exhaust1);
                
                const exhaust2 = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                exhaust2.position.set(0.6, 0.4, -2.6);
                exhaust2.rotation.x = Math.PI / 2;
                carGroup.add(exhaust2);

                return carGroup;
            }
        };

        // Car Model 3: Formula-style Car
        const carModel3 = {
            name: "Fórmula",
            color: 0xff3366,
            acceleration: 0.22,
            maxSpeed: 250,
            torqueMultiplier: 0.9,
            createModel: function() {
                const carGroup = new THREE.Group();

                // Main body
                const bodyGeometry = new THREE.BoxGeometry(1.8, 0.6, 4.5);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: this.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.3;
                body.castShadow = true;
                carGroup.add(body);

                // Cockpit
                const cockpitGeometry = new THREE.BoxGeometry(0.8, 0.4, 1.2);
                const cockpitMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                cockpit.position.set(0, 0.6, 0.5);
                cockpit.castShadow = true;
                carGroup.add(cockpit);

                // Rear wing
                const wingGeometry = new THREE.BoxGeometry(2.0, 0.1, 0.3);
                const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                wing.position.set(0, 0.8, -1.8);
                wing.castShadow = true;
                carGroup.add(wing);
                
                const wingSupportGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
                const wingSupportMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                
                const wingSupport1 = new THREE.Mesh(wingSupportGeometry, wingSupportMaterial);
                wingSupport1.position.set(-0.8, 0.5, -1.8);
                carGroup.add(wingSupport1);
                
                const wingSupport2 = new THREE.Mesh(wingSupportGeometry, wingSupportMaterial);
                wingSupport2.position.set(0.8, 0.5, -1.8);
                carGroup.add(wingSupport2);

                // Wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 16);
                wheelGeometry.rotateZ(Math.PI / 2);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });

                const wheelPositions = [
                    { x: -1.0, y: 0.3, z: 1.5 },
                    { x: 1.0, y: 0.3, z: 1.5 },
                    { x: -1.0, y: 0.3, z: -1.5 },
                    { x: 1.0, y: 0.3, z: -1.5 }
                ];

                this.wheels = [];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(pos.x, pos.y, pos.z);
                    wheel.castShadow = true;
                    carGroup.add(wheel);
                    this.wheels.push(wheel);
                });

                return carGroup;
            }
        };
    </script>
    
    <!-- Track models -->
    <script id="trackModels">
        // Track Model 1: Oval Track
        const trackModel1 = {
            name: "Pista Oval",
            createModel: function() {
                const trackGroup = new THREE.Group();

                // Track surface
                const trackGeometry = new THREE.RingGeometry(80, 120, 64, 8);
                const trackMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.rotation.x = -Math.PI / 2;
                trackMesh.receiveShadow = true;
                trackGroup.add(trackMesh);

                // Track borders
                const borderGeometry = new THREE.TorusGeometry(120, 2, 16, 64);
                const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const outerBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                outerBorder.rotation.x = Math.PI / 2;
                outerBorder.position.y = 0.1;
                outerBorder.receiveShadow = true;
                trackGroup.add(outerBorder);

                const innerBorder = new THREE.Mesh(new THREE.TorusGeometry(80, 2, 16, 64), borderMaterial);
                innerBorder.rotation.x = Math.PI / 2;
                innerBorder.position.y = 0.1;
                innerBorder.receiveShadow = true;
                trackGroup.add(innerBorder);

                // Track markings
                const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const line = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.2, 12),
                        lineMaterial
                    );
                    line.position.set(Math.cos(angle) * 100, 0.11, Math.sin(angle) * 100);
                    line.rotation.y = -angle;
                    line.receiveShadow = true;
                    trackGroup.add(line);
                }

                // Grass area
                const grassGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
                const grassMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228822,
                    roughness: 1,
                    metalness: 0
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.y = -0.1;
                grass.receiveShadow = true;
                trackGroup.add(grass);

                return trackGroup;
            },
            checkpoints: [
                {x: 100, z: 0, radius: 20}, // Start/finish line
                {x: 0, z: 100, radius: 20}, // Turn 1
                {x: -100, z: 0, radius: 20}, // Turn 2
                {x: 0, z: -100, radius: 20}  // Turn 3
            ]
        };

        // Track Model 2: Circuit Track
        const trackModel2 = {
            name: "Circuito",
            createModel: function() {
                const trackGroup = new THREE.Group();

                // Create the track path
                const path = new THREE.CurvePath();
                
                // Starting straight
                path.add(new THREE.LineCurve3(
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(100, 0, 0)
                ));
                
                // First curve
                const arc1 = new THREE.ArcCurve(
                    100, 0, // center
                    50, // radius
                    Math.PI, Math.PI * 1.5, // angles
                    false // clockwise
                );
                path.add(arc1);
                
                // Back straight
                path.add(new THREE.LineCurve3(
                    new THREE.Vector3(100, -50, 0),
                    new THREE.Vector3(0, -50, 0)
                ));
                
                // Second curve
                const arc2 = new THREE.ArcCurve(
                    0, -50, // center
                    50, // radius
                    Math.PI * 1.5, Math.PI * 2, // angles
                    false // clockwise
                );
                path.add(arc2);
                
                // Connect back to start
                path.add(new THREE.LineCurve3(
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 0)
                ));

                // Create track geometry
                const trackGeometry = new THREE.TubeGeometry(path, 64, 10, 8, false);
                const trackMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.rotation.x = -Math.PI / 2;
                trackMesh.position.y = 0.1;
                trackMesh.receiveShadow = true;
                trackGroup.add(trackMesh);

                // Grass area
                const grassGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
                const grassMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228822,
                    roughness: 1,
                    metalness: 0
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.y = -0.1;
                grass.receiveShadow = true;
                trackGroup.add(grass);

                // Track borders
                const borderGeometry = new THREE.TubeGeometry(path, 64, 12, 8, false);
                const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.rotation.x = -Math.PI / 2;
                border.position.y = 0.11;
                border.receiveShadow = true;
                trackGroup.add(border);

                return trackGroup;
            },
            checkpoints: [
                {x: 0, z: 0, radius: 15}, // Start/finish line
                {x: 100, z: -25, radius: 15}, // End of straight
                {x: 50, z: -50, radius: 15}, // Mid curve
                {x: 0, z: -25, radius: 15}  // Back straight
            ]
        };
    </script>
    
    <!-- Sound Manager -->
    <script>
        class SoundManager {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.sounds = {};
                this.engineSoundSource = null;
                this.engineGain = null;
                this.enginePanner = null;
                this.enginePlaying = false;
            }

            init() {
                // Create engine sound nodes
                this.engineGain = this.audioContext.createGain();
                this.enginePanner = this.audioContext.createStereoPanner();
                this.engineGain.connect(this.enginePanner);
                this.enginePanner.connect(this.audioContext.destination);
                this.engineGain.gain.value = 0.3;
            }

            loadSound(name, url) {
                return new Promise((resolve, reject) => {
                    fetch(url)
                        .then(response => response.arrayBuffer())
                        .then(data => this.audioContext.decodeAudioData(data))
                        .then(buffer => {
                            this.sounds[name] = buffer;
                            resolve();
                        })
                        .catch(error => reject(error));
                });
            }

            playSound(name, loop = false, volume = 1.0) {
                if (!this.sounds[name]) return;
                
                const source = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();
                
                source.buffer = this.sounds[name];
                source.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                gainNode.gain.value = volume;
                source.loop = loop;
                source.start();
                
                return source;
            }

            startEngineSound() {
                if (this.enginePlaying) return;
                
                // Create engine sound oscillator
                this.engineSoundSource = this.audioContext.createOscillator();
                this.engineSoundSource.type = 'sawtooth';
                this.engineSoundSource.frequency.value = 100;
                
                // Create filter for engine sound
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 500;
                
                this.engineSoundSource.connect(filter);
                filter.connect(this.engineGain);
                this.engineSoundSource.start();
                this.enginePlaying = true;
            }

            updateEngineSound(rpm, maxRpm) {
                if (!this.enginePlaying) return;
                
                // RPM range from 0.0 to 1.0
                const rpmRatio = Math.min(1.0, rpm / maxRpm);
                
                // Update frequency based on RPM
                const minFreq = 80;
                const maxFreq = 600;
                this.engineSoundSource.frequency.value = minFreq + (maxFreq - minFreq) * rpmRatio;
                
                // Update filter cutoff based on RPM
                const minCutoff = 500;
                const maxCutoff = 2000;
                filter.frequency.value = minCutoff + (maxCutoff - minCutoff) * rpmRatio;
                
                // Update volume based on RPM
                this.engineGain.gain.value = 0.2 + 0.3 * rpmRatio;
            }

            stopEngineSound() {
                if (this.engineSoundSource && this.enginePlaying) {
                    this.engineSoundSource.stop();
                    this.enginePlaying = false;
                }
            }

            playGearShift() {
                this.playSound('gear_shift', false, 0.5);
            }

            playSkid() {
                this.playSound('skid', false, 0.7);
            }
        }
    </script>

    <script>
        // Variáveis globais
        let scene, camera, renderer;
        let localCar, remoteCar, track;
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let players = {};
        let ws = null;
        let peerConnection = null;
        let dataChannel = null;
        let lastMoveSent = 0;
        let startTime = null;
        let finishTimes = {};
        let soundManager = new SoundManager();

        // Configurações do jogo
        const gameConfig = {
            playerId: null,
            playerName: "Player",
            opponentName: "Oponente",
            roomId: null,
            isOffline: false,
            status: 'waiting',
            gear: 'N',
            speed: 0,
            acceleration: 0,
            torque: 0,
            steering: 0,
            position: new THREE.Vector3(100, 0.5, 0),
            rotation: 0,
            lap: 0,
            lastCheckpoint: 0,
            upgrades: {
                torque: 0,
                speed: 0,
                gears: 0
            },
            money: 300,
            betAmount: 0,
            selectedCar: null
        };

        // Configurações de marchas
        const gearSettings = {
            'R': { minSpeed: -20, maxSpeed: 0, optimalMin: -14, optimalMax: -7, torqueMultiplier: 0.7 },
            'N': { minSpeed: -10, maxSpeed: 10, optimalMin: 0, optimalMax: 0, torqueMultiplier: 0.1 },            
            '1': { minSpeed: 0, maxSpeed: 120, optimalMin: 16, optimalMax: 20, torqueMultiplier: 1.0 },
            '2': { minSpeed: 0, maxSpeed: 120, optimalMin: 35, optimalMax: 46, torqueMultiplier: 0.9 },
            '3': { minSpeed: 0, maxSpeed: 120, optimalMin: 54, optimalMax: 58, torqueMultiplier: 0.8 },
            '4': { minSpeed: 0, maxSpeed: 120, optimalMin: 70, optimalMax: 78, torqueMultiplier: 0.7 },
            '5': { minSpeed: 0, maxSpeed: 120, optimalMin: 85, optimalMax: 110, torqueMultiplier: 0.6 }
        };

        // Configuração WebRTC
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                {
                    urls: 'turn:turn.speed.cloudflare.com:50000',
                    username: 'd1a7f09155fb30285724a3a056ca2edf17956674aff12909ff133dcec42994b2614cdd0a380a1b65124def1e3d0208543050d14b77d1a7533f9da35893ee2ed9',
                    credential: 'aba9b169546eb6dcc7bfb1cdf34544cf95b5161d602e3b5fa7c8342b2e9802fb'
                },
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ]
        };

        const SERVER_URL = 'wss://heroic-hope-production-bbdc.up.railway.app';

        // Elementos da interface
        const startScreen = document.getElementById('startScreen');
        const upgradeScreen = document.getElementById('upgradeScreen');
        const gameScreen = document.getElementById('gameScreen');
        const startButton = document.getElementById('startButton');
        const offlineButton = document.getElementById('offlineButton');
        const raceButton = document.getElementById('raceButton');
        const generateIdButton = document.getElementById('generateIdButton');
        const copyIdButton = document.getElementById('copyIdButton');
        const roomInput = document.getElementById('roomInput');
        const playerNameInput = document.getElementById('playerNameInput');
        const statusDisplay = document.getElementById('status');
        const speedDisplay = document.getElementById('speedDisplay');
        const gearDisplay = document.getElementById('gearDisplay');
        const rpmNeedle = document.getElementById('rpmNeedle');
        const playerNameTag = document.getElementById('playerNameTag');
        const moneyDisplay = document.getElementById('moneyDisplay');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const endGameScreen = document.getElementById('endGameScreen');
        const endGameMessage = document.getElementById('endGameMessage');
        const raceResults = document.getElementById('raceResults');
        const rematchBtn = document.getElementById('rematchBtn');
        const exitBtn = document.getElementById('exitBtn');
        const betValue = document.getElementById('betValue');
        const betIncrease = document.getElementById('betIncrease');
        const betDecrease = document.getElementById('betDecrease');

        // Elementos de controle mobile
        const accelerateBtn = document.getElementById('accelerateBtn');
        const brakeBtn = document.getElementById('brakeBtn');
        const gearUpBtn = document.getElementById('gearUpBtn');
        const gearDownBtn = document.getElementById('gearDownBtn');
        const dpadLeft = document.getElementById('dpadLeft');
        const dpadRight = document.getElementById('dpadRight');

        // Carros e pistas disponíveis
        const carModels = [carModel1, carModel2, carModel3];
        const trackModels = [trackModel1, trackModel2];

        // Inicialização do jogo
        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, -20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Carregar sons
            soundManager.init();
            // Em um ambiente real, carregaríamos os sons de arquivos, mas aqui vamos gerar alguns sons sintéticos
            generateSyntheticSounds();

            // Selecionar carro padrão se nenhum foi selecionado
            if (!gameConfig.selectedCar) {
                gameConfig.selectedCar = carModels[0];
            }

            createTrack();
            createLocalCar();
            if (!gameConfig.isOffline) {
                createRemoteCar();
            }

            setupControls();
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function generateSyntheticSounds() {
            // Gerar som sintético de troca de marcha
            const gearShiftDuration = 0.3;
            const sampleRate = soundManager.audioContext.sampleRate;
            const buffer = soundManager.audioContext.createBuffer(1, sampleRate * gearShiftDuration, sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < data.length; i++) {
                const t = i / sampleRate;
                // Um som de "clique" curto
                data[i] = Math.sin(2 * Math.PI * 500 * t) * Math.exp(-20 * t);
            }
            soundManager.sounds['gear_shift'] = buffer;

            // Gerar som sintético de derrapagem
            const skidDuration = 1.0;
            const skidBuffer = soundManager.audioContext.createBuffer(1, sampleRate * skidDuration, sampleRate);
            const skidData = skidBuffer.getChannelData(0);
            
            for (let i = 0; i < skidData.length; i++) {
                const t = i / sampleRate;
                // Ruído branco com envelope
                skidData[i] = (Math.random() * 2 - 1) * Math.exp(-2 * t);
            }
            soundManager.sounds['skid'] = skidBuffer;
        }

        // Criar pista de corrida
        function createTrack() {
            track = trackModels[0].createModel();
            scene.add(track);
        }

        // Criar carro local
        function createLocalCar() {
            const carModel = gameConfig.selectedCar;
            localCar = {
                group: carModel.createModel(),
                wheels: carModel.wheels,
                position: new THREE.Vector3(100, 0.5, 0),
                rotation: 0,
                targetRotation: 0,
                nameTag: createNameTag(gameConfig.playerName, carModel.color)
            };

            localCar.group.add(localCar.nameTag);
            scene.add(localCar.group);
            players[gameConfig.playerId] = {
                x: localCar.position.x,
                z: localCar.position.z,
                rotation: localCar.rotation
            };
        }

        // Criar carro remoto
        function createRemoteCar() {
            const opponentCar = carModels[1]; // Carro diferente para o oponente
            remoteCar = {
                group: opponentCar.createModel(),
                wheels: opponentCar.wheels,
                position: new THREE.Vector3(90, 0.5, 0),
                rotation: 0,
                nameTag: createNameTag(gameConfig.opponentName, opponentCar.color)
            };

            remoteCar.group.add(remoteCar.nameTag);
            scene.add(remoteCar.group);

            const opponentId = gameConfig.playerId === 0 ? 1 : 0;
            players[opponentId] = {
                x: remoteCar.position.x,
                z: remoteCar.position.z,
                rotation: remoteCar.rotation
            };
        }

        // Criar etiqueta de nome
        function createNameTag(name, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            // Fundo
            context.fillStyle = `rgba(0, 0, 0, 0.7)`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Texto
            context.fillStyle = `rgb(${(color >> 16) & 0xff}, ${(color >> 8) & 0xff}, ${color & 0xff})`;
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.fillText(name, canvas.width/2, canvas.height/2 + 8);
            
            // Criar sprite
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(10, 2.5, 1);
            sprite.position.y = 3;
            
            return sprite;
        }

        // Configurar controles
        function setupControls() {
            const keys = {};

            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'KeyW') shiftGearUp();
                if (e.code === 'KeyS') shiftGearDown();
            });

            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            accelerateBtn.addEventListener('touchstart', () => {
                keys['Space'] = true;
                accelerateBtn.style.background = 'rgba(0, 255, 234, 0.5)';
            });

            accelerateBtn.addEventListener('touchend', () => {
                keys['Space'] = false;
                accelerateBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            });

            brakeBtn.addEventListener('touchstart', () => {
                keys['KeyS'] = true;
                brakeBtn.style.background = 'rgba(0, 255, 234, 0.5)';
            });

            brakeBtn.addEventListener('touchend', () => {
                keys['KeyS'] = false;
                brakeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            });

            gearUpBtn.addEventListener('click', shiftGearUp);
            gearDownBtn.addEventListener('click', shiftGearDown);

            dpadLeft.addEventListener('touchstart', () => { keys['KeyA'] = true; });
            dpadLeft.addEventListener('touchend', () => { keys['KeyA'] = false; });
            dpadRight.addEventListener('touchstart', () => { keys['KeyD'] = true; });
            dpadRight.addEventListener('touchend', () => { keys['KeyD'] = false; });

            function updateControls() {
                gameConfig.acceleration = keys['Space'] ? 1 : 0;
                if (keys['KeyS'] && !keys['Space']) gameConfig.acceleration = -0.5;

                gameConfig.steering = 0;
                if (keys['KeyA']) gameConfig.steering = 1;
                if (keys['KeyD']) gameConfig.steering = -1;

                updatePhysics();
            }

            setInterval(updateControls, 16);
        }

        // Gerar ID de sala
        function generateRoomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = '';
            for (let i = 0; i < 5; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
        }

        // Conectar ao servidor WebSocket
        function connectToServer() {
            if (!gameConfig.roomId) {
                statusDisplay.textContent = 'Por favor, insira um ID de sala';
                return;
            }

            statusDisplay.textContent = 'Conectando ao servidor...';
            loadingOverlay.style.display = 'flex';

            ws = new WebSocket(SERVER_URL);

            ws.onopen = () => {
                statusDisplay.textContent = 'Aguardando oponente...';
                ws.send(JSON.stringify({ 
                    type: 'join', 
                    roomId: gameConfig.roomId,
                    playerName: gameConfig.playerName
                }));
            };

            ws.onerror = (error) => {
                statusDisplay.textContent = 'Erro na conexão. Tente novamente.';
                loadingOverlay.style.display = 'none';
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                statusDisplay.textContent = 'Conexão fechada.';
                loadingOverlay.style.display = 'none';
                gameConfig.status = 'waiting';
            };

            ws.onmessage = async (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'start') {
                        gameConfig.playerId = data.playerId;
                        gameConfig.opponentName = data.opponentName || "Oponente";
                        statusDisplay.textContent = `Você é o jogador ${gameConfig.playerId + 1}`;
                        initPeerConnection();
                        if (gameConfig.playerId === 0) {
                            dataChannel = peerConnection.createDataChannel('gameData');
                            setupDataChannel();
                            const offer = await peerConnection.createOffer();
                            await peerConnection.setLocalDescription(offer);
                            ws.send(JSON.stringify({ type: 'offer', sdp: offer }));
                        }
                    } else if (data.type === 'offer') {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        ws.send(JSON.stringify({ type: 'answer', sdp: answer }));
                    } else if (data.type === 'answer') {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    } else if (data.type === 'ice') {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    } else if (data.type === 'error') {
                        statusDisplay.textContent = `Erro: ${data.message}`;
                        loadingOverlay.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error processing message:', error);
                    statusDisplay.textContent = 'Erro no processamento';
                    loadingOverlay.style.display = 'none';
                }
            };
        }

        // Configurar WebRTC
        function initPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ type: 'ice', candidate: event.candidate }));
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                statusDisplay.textContent = `Estado: ${state}`;
                if (state === 'failed') {
                    statusDisplay.textContent = 'Conexão falhou. Tente novamente.';
                    loadingOverlay.style.display = 'none';
                }
            };

            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel();
            };
        }

        // Configurar canal de dados
        function setupDataChannel() {
            dataChannel.onopen = () => {
                statusDisplay.textContent = 'Conexão P2P estabelecida!';
                startGame();
            };

            dataChannel.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'move') {
                        const opponentId = gameConfig.playerId === 0 ? 1 : 0;
                        if (players[opponentId] && remoteCar) {
                            players[opponentId].x = data.position.x;
                            players[opponentId].z = data.position.z;
                            players[opponentId].rotation = data.position.rotation;
                            remoteCar.position.set(data.position.x, 0.5, data.position.z);
                            remoteCar.group.position.copy(remoteCar.position);
                            remoteCar.rotation = data.position.rotation;
                            remoteCar.group.rotation.y = data.position.rotation;
                            const wheelRotation = data.speed * deltaTime * 2;
                            remoteCar.wheels.forEach(wheel => {
                                wheel.rotation.x += wheelRotation;
                            });
                        }
                    } else if (data.type === 'lap') {
                        const opponentId = gameConfig.playerId === 0 ? 1 : 0;
                        players[opponentId].lap = data.lapCount;
                        if (data.lapCount >= 3 && !gameConfig.status.includes('finished')) {
                            finishTimes[opponentId] = Date.now() - startTime;
                            gameConfig.status = 'opponent_finished';
                            showEndGameScreen(`${gameConfig.opponentName} venceu!`);
                        }
                    } else if (data.type === 'restart') {
                        restartGame();
                    }
                } catch (error) {
                    console.error('DataChannel error:', error);
                }
            };
        }

        // Iniciar jogo
        function startGame() {
            players = {};
            gameConfig.lap = 0;
            gameConfig.status = 'playing';
            startTime = Date.now();
            finishTimes = {};
            soundManager.startEngineSound();

            players[gameConfig.playerId] = {
                x: 100,
                z: 0,
                rotation: 0,
                lap: 0,
                lastCheckpoint: 0
            };

            localCar.position.set(100, 0.5, 0);
            localCar.rotation = 0;
            localCar.targetRotation = 0;
            localCar.group.position.copy(localCar.position);
            localCar.group.rotation.y = localCar.rotation;

            if (!gameConfig.isOffline) {
                const opponentId = gameConfig.playerId === 0 ? 1 : 0;
                players[opponentId] = {
                    x: 90,
                    z: 0,
                    rotation: 0,
                    lap: 0
                };
                remoteCar.position.set(90, 0.5, 0);
                remoteCar.rotation = 0;
                remoteCar.group.position.copy(remoteCar.position);
                remoteCar.group.rotation.y = remoteCar.rotation;
            }

            playerNameTag.textContent = gameConfig.playerName;
            speedDisplay.textContent = '0';
            gearDisplay.textContent = 'N';
            rpmNeedle.style.transform = `translate(-50%, -100%) rotate(-135deg)`;
            loadingOverlay.style.display = 'none';
            endGameScreen.style.display = 'none';
        }

        // Reiniciar jogo
        function restartGame() {
            gameConfig.lap = 0;
            gameConfig.status = 'playing';
            startTime = Date.now();
            finishTimes = {};
            soundManager.startEngineSound();

            players[gameConfig.playerId] = {
                x: 100,
                z: 0,
                rotation: 0,
                lap: 0,
                lastCheckpoint: 0
            };

            localCar.position.set(100, 0.5, 0);
            localCar.rotation = 0;
            localCar.targetRotation = 0;
            localCar.group.position.copy(localCar.position);
            localCar.group.rotation.y = localCar.rotation;

            if (!gameConfig.isOffline) {
                const opponentId = gameConfig.playerId === 0 ? 1 : 0;
                players[opponentId] = {
                    x: 90,
                    z: 0,
                    rotation: 0,
                    lap: 0
                };
                remoteCar.position.set(90, 0.5, 0);
                remoteCar.rotation = 0;
                remoteCar.group.position.copy(remoteCar.position);
                remoteCar.group.rotation.y = remoteCar.rotation;
            }

            speedDisplay.textContent = '0';
            gearDisplay.textContent = 'N';
            rpmNeedle.style.transform = `translate(-50%, -100%) rotate(-135deg)`;
            endGameScreen.style.display = 'none';
        }

        // Atualizar física do carro
        function updatePhysics() {
            const carModel = gameConfig.selectedCar;
            const gear = gearSettings[gameConfig.gear];
            const speed = Math.abs(gameConfig.speed);

            // Calcular torque baseado na velocidade e faixa ideal
            let torqueEfficiency = 0.1;
            if (gameConfig.gear === 'N') {
                torqueEfficiency = gear.torqueMultiplier;
            } else if (gameConfig.gear === 'R') {
                if (gameConfig.speed >= gear.optimalMin && gameConfig.speed <= gear.optimalMax) {
                    torqueEfficiency = gear.torqueMultiplier;
                } else {
                    const distance = Math.min(
                        Math.abs(gameConfig.speed - gear.optimalMin),
                        Math.abs(gameConfig.speed - gear.optimalMax)
                    );
                    torqueEfficiency = gear.torqueMultiplier * Math.max(0.1, 1 - (distance / 10));
                }
            } else {
                if (speed >= gear.optimalMin && speed <= gear.optimalMax) {
                    torqueEfficiency = gear.torqueMultiplier;
                } else {
                    const distance = Math.min(
                        Math.abs(speed - gear.optimalMin),
                        Math.abs(speed - gear.optimalMax)
                    );
                    torqueEfficiency = gear.torqueMultiplier * Math.max(0.1, 1 - (distance / 10));
                }
            }

            // Aplicar upgrades e características do carro
            const torqueMultiplier = (1 + (gameConfig.upgrades.torque * 0.2)) * carModel.torqueMultiplier;
            const speedMultiplier = (1 + (gameConfig.upgrades.speed * 0.15)) * (carModel.maxSpeed / 220);
            const gearMultiplier = 1 + (gameConfig.upgrades.gears * 0.25);

            // Calcular aceleração
            let acceleration = gameConfig.acceleration * torqueEfficiency * torqueMultiplier;
            if (gameConfig.gear === 'N') {
                acceleration *= 0.1; // Reduzir aceleração em neutro
            }

            // Atualizar velocidade
            gameConfig.speed += acceleration * deltaTime * 20;
            if (gameConfig.gear === 'R') {
                gameConfig.speed = Math.max(-gear.maxSpeed * speedMultiplier, Math.min(0, gameConfig.speed));
            } else if (gameConfig.gear === 'N') {
                gameConfig.speed *= 0.95;
            } else {
                gameConfig.speed = Math.max(0, Math.min(gear.maxSpeed * speedMultiplier, gameConfig.speed));
            }

            // Aplicar arrasto
            gameConfig.speed *= 0.999;

            // Atualizar torque para exibição
            gameConfig.torque = Math.round(torqueEfficiency * 100);

            // Atualizar direção
            const steeringAmount = gameConfig.steering * deltaTime * 1.5;
            if (Math.abs(gameConfig.speed) > 5) {
                localCar.targetRotation += steeringAmount * Math.sign(gameConfig.speed);
            }

            localCar.rotation += (localCar.targetRotation - localCar.rotation) * 0.1;

            const direction = new THREE.Vector3(
                Math.sin(localCar.rotation),
                0,
                Math.cos(localCar.rotation)
            );

            localCar.position.add(direction.multiplyScalar(gameConfig.speed * deltaTime));
            players[gameConfig.playerId].x = localCar.position.x;
            players[gameConfig.playerId].z = localCar.position.z;
            players[gameConfig.playerId].rotation = localCar.rotation;

            checkLapCompletion();

            localCar.group.position.copy(localCar.position);
            localCar.group.rotation.y = localCar.rotation;

            const wheelRotation = gameConfig.speed * deltaTime * 2;
            localCar.wheels.forEach(wheel => {
                wheel.rotation.x += wheelRotation;
            });

            // Atualizar som do motor
            const maxRpm = 8000;
            const rpm = Math.min(maxRpm, 1000 + Math.abs(gameConfig.speed) * 30);
            soundManager.updateEngineSound(rpm, maxRpm);

            // Verificar se está derrapando
            if (Math.abs(gameConfig.steering) > 0.5 && Math.abs(gameConfig.speed) > 50) {
                if (Math.random() < 0.1) {
                    soundManager.playSkid();
                }
            }

            updateCamera();
            updateUI();

            const now = Date.now();
            if (now - lastMoveSent > 50 && dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ 
                    type: 'move', 
                    playerId: gameConfig.playerId, 
                    position: {
                        x: localCar.position.x,
                        z: localCar.position.z,
                        rotation: localCar.rotation
                    },
                    speed: gameConfig.speed,
                    lapCount: gameConfig.lap
                }));
                lastMoveSent = now;
            }
        }

        // Verificar se completou uma volta
        function checkLapCompletion() {
            // Verificação simplificada para demonstração
            if (localCar.position.z > -1 && localCar.position.z < 1 && localCar.position.x > 80 && localCar.position.x < 120) {
                if (gameConfig.lastCheckpoint === 1) {
                    gameConfig.lap++;
                    gameConfig.lastCheckpoint = 0;
                    players[gameConfig.playerId].lap = gameConfig.lap;

                    if (dataChannel && dataChannel.readyState === 'open') {
                        dataChannel.send(JSON.stringify({ 
                            type: 'lap', 
                            playerId: gameConfig.playerId,
                            lapCount: gameConfig.lap
                        }));
                    }

                    if (gameConfig.lap >= 3 && !gameConfig.status.includes('finished')) {
                        finishTimes[gameConfig.playerId] = Date.now() - startTime;
                        gameConfig.status = 'finished';
                        showEndGameScreen('Você venceu!');
                        
                        // Ganhar dinheiro da aposta
                        gameConfig.money += gameConfig.betAmount * 2;
                        
                        if (dataChannel && dataChannel.readyState === 'open') {
                            dataChannel.send(JSON.stringify({ 
                                type: 'raceOver', 
                                winnerId: gameConfig.playerId
                            }));
                        }
                    }
                }
            } else if (localCar.position.z > 45 || localCar.position.z < -45) {
                gameConfig.lastCheckpoint = 1;
            }
        }

        // Atualizar posição da câmera
        function updateCamera() {
            const carPosition = localCar.position.clone();
            const offset = new THREE.Vector3(
                Math.sin(localCar.rotation) * 15,
                -15,
                Math.cos(localCar.rotation) * 15
            );

            camera.position.copy(carPosition.sub(offset));
            camera.lookAt(localCar.position.x, localCar.position.y + 2, localCar.position.z);
        }

        // Atualizar interface do usuário
        function updateUI() {
            speedDisplay.textContent = Math.abs(Math.round(gameConfig.speed));
            gearDisplay.textContent = gameConfig.gear;
            
            // Atualizar RPM gauge
            const maxRpm = 8000;
            const rpm = Math.min(maxRpm, 1000 + Math.abs(gameConfig.speed) * 30);
            const rpmAngle = -135 + (rpm / maxRpm) * 270; // -135° to 135°
            rpmNeedle.style.transform = `translate(-50%, -100%) rotate(${rpmAngle}deg)`;
        }

        // Trocar marcha para cima
        function shiftGearUp() {
            const gears = ['R', 'N', '1', '2', '3', '4', '5'];
            const currentIndex = gears.indexOf(gameConfig.gear);
            if (currentIndex < gears.length - 1) {
                gameConfig.gear = gears[currentIndex + 1];
                soundManager.playGearShift();
            }
        }

        // Trocar marcha para baixo
        function shiftGearDown() {
            const gears = ['R', 'N', '1', '2', '3', '4', '5'];
            const currentIndex = gears.indexOf(gameConfig.gear);
            if (currentIndex > 0) {
                gameConfig.gear = gears[currentIndex - 1];
                soundManager.playGearShift();
            }
        }

        // Redimensionar a cena
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Exibir tela de fim de jogo
        function showEndGameScreen(message) {
            endGameScreen.style.display = 'block';
            endGameMessage.textContent = message;

            let resultsHTML = '<h3>Resultados:</h3>';
            Object.keys(finishTimes).sort((a, b) => finishTimes[a] - finishTimes[b]).forEach(id => {
                const playerName = id == gameConfig.playerId ? gameConfig.playerName : gameConfig.opponentName;
                const time = (finishTimes[id] / 1000).toFixed(2);
                resultsHTML += `<p>${playerName}: ${time}s</p>`;
            });

            raceResults.innerHTML = resultsHTML;
            gameConfig.status = 'finished';
            soundManager.stopEngineSound();
        }

        // Fechar conexões
        function closeConnections() {
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
            soundManager.stopEngineSound();
        }

        // Loop de animação
        function animate() {
            requestAnimationFrame(animate);
            deltaTime = Math.min(clock.getDelta(), 0.1); // Limit delta time to prevent physics issues

            if (gameConfig.status === 'playing') {
                updatePhysics();
            }

            renderer.render(scene, camera);
        }

        // Eventos de interface
        window.addEventListener('load', () => {
            // Inicializar valores
            playerNameTag.textContent = gameConfig.playerName;
            betValue.textContent = gameConfig.betAmount;
            
            // Event listeners
            generateIdButton.addEventListener('click', () => {
                gameConfig.roomId = generateRoomId();
                roomInput.value = gameConfig.roomId;
                statusDisplay.textContent = 'ID gerado!';
            });

            copyIdButton.addEventListener('click', () => {
                roomInput.select();
                document.execCommand('copy');
                statusDisplay.textContent = 'ID copiado!';
            });

            startButton.addEventListener('click', () => {
                gameConfig.isOffline = false;
                gameConfig.playerName = playerNameInput.value || "Player";
                gameConfig.roomId = roomInput.value.trim();
                if (!gameConfig.roomId) {
                    statusDisplay.textContent = 'Por favor, insira ou gere um ID de sala';
                    return;
                }
                connectToServer();
                startScreen.classList.add('hidden');
                upgradeScreen.classList.remove('hidden');
                moneyDisplay.textContent = `Dinheiro: $${gameConfig.money}`;
            });

            offlineButton.addEventListener('click', () => {
                gameConfig.isOffline = true;
                gameConfig.playerName = playerNameInput.value || "Player";
                startScreen.classList.add('hidden');
                upgradeScreen.classList.remove('hidden');
                moneyDisplay.textContent = `Dinheiro: $${gameConfig.money}`;
                statusDisplay.textContent = 'Modo Offline';
            });

            raceButton.addEventListener('click', () => {
                upgradeScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                startGame();
            });

            document.querySelectorAll('.buy-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const upgradeType = e.target.dataset.upgrade;
                    const cost = upgradeType === 'torque' ? 100 : upgradeType === 'speed' ? 150 : 200;

                    if (gameConfig.money >= cost) {
                        gameConfig.money -= cost;
                        gameConfig.upgrades[upgradeType]++;
                        moneyDisplay.textContent = `Dinheiro: $${gameConfig.money}`;
                        e.target.textContent = 'COMPRADO!';
                        e.target.disabled = true;

                        // Desabilitar botões se não houver dinheiro suficiente
                        document.querySelectorAll('.buy-button').forEach(btn => {
                            const btnCost = btn.dataset.upgrade === 'torque' ? 100 : 
                                           btn.dataset.upgrade === 'speed' ? 150 : 200;
                            btn.disabled = gameConfig.money < btnCost;
                        });
                    }
                });
            });

            betIncrease.addEventListener('click', () => {
                if (gameConfig.money > gameConfig.betAmount) {
                    gameConfig.betAmount = Math.min(gameConfig.money, gameConfig.betAmount + 10);
                    betValue.textContent = gameConfig.betAmount;
                }
            });

            betDecrease.addEventListener('click', () => {
                gameConfig.betAmount = Math.max(0, gameConfig.betAmount - 10);
                betValue.textContent = gameConfig.betAmount;
            });

            rematchBtn.addEventListener('click', () => {
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'restart' }));
                    restartGame();
                } else {
                    statusDisplay.textContent = 'Reconectando...';
                    gameConfig.roomId = roomInput.value.trim();
                    if (gameConfig.roomId) {
                        connectToServer();
                        upgradeScreen.classList.add('hidden');
                        gameScreen.classList.remove('hidden');
                        startGame();
                    }
                }
            });

            exitBtn.addEventListener('click', () => {
                closeConnections();
                gameConfig.status = 'waiting';
                endGameScreen.style.display = 'none';
                startScreen.classList.remove('hidden');
                statusDisplay.textContent = 'Pronto para jogar novamente';
            });

            initGame();
        });
    </script>
</body>
</html>