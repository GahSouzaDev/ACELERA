<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Corrida Arcade Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            transition: opacity 0.5s;
        }

        .hidden {
            display: none;
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffea;
            color: #00ffea;
            letter-spacing: 3px;
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 30px;
            color: #ffcc00;
        }

        button {
            background: #ff3366;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        button:hover {
            background: #ff0066;
            transform: scale(1.05);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        .upgrade-option {
            background: rgba(30, 30, 60, 0.8);
            padding: 15px;
            margin: 10px;
            border-radius: 10px;
            width: 300px;
            text-align: center;
            border: 2px solid #00ffea;
        }

        .upgrade-option h3 {
            color: #ffcc00;
            margin-bottom: 10px;
        }

        .upgrade-option p {
            margin-bottom: 10px;
        }

        .stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffea;
            z-index: 5;
        }

        .stats div {
            margin: 5px 0;
        }

        #speedDisplay {
            font-size: 1.8rem;
            color: #ffcc00;
        }

        #gearDisplay {
            font-size: 1.5rem;
            color: #ff3366;
        }

        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffea;
            z-index: 5;
            font-size: 1.2rem;
            color: #00ffea;
        }

        .torque-bar {
            width: 250px;
            height: 30px;
            background: #333;
            border: 2px solid #00ffea;
            border-radius: 15px;
            margin-top: 10px;
            overflow: hidden;
            position: relative;
        }

        .torque-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffcc00, #00ff00);
            width: 0%;
            transition: width 0.1s;
        }

        .torque-optimal {
            position: absolute;
            height: 100%;
            width: 4px;
            background: #00ffea;
            left: 70%;
        }

        #mobileControls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 5;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px;
            color: white;
            font-size: 1.5rem;
            border: 2px solid #00ffea;
            user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            background: rgba(0, 255, 234, 0.3);
        }

        .gear-controls {
            flex-direction: row;
        }

        .gear-btn {
            width: 60px;
            height: 60px;
            margin: 5px;
            background: rgba(255, 51, 102, 0.7);
        }

        .gear-display {
            background: rgba(30, 30, 60, 0.8);
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffcc00;
            border: 2px solid #00ffea;
            margin-top: 10px;
        }

        #dPad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .dpad-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #00ffea;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
        }

        .dpad-btn:nth-child(1) {
            grid-column: 2;
            grid-row: 1;
        }

        .dpad-btn:nth-child(2) {
            grid-column: 1;
            grid-row: 2;
        }

        .dpad-btn:nth-child(3) {
            grid-column: 2;
            grid-row: 2;
        }

        .dpad-btn:nth-child(4) {
            grid-column: 3;
            grid-row: 2;
        }

        .dpad-btn:nth-child(5) {
            grid-column: 2;
            grid-row: 3;
        }

        .smoke-particle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
        }

        #instructions {
            max-width: 600px;
            text-align: center;
            margin: 20px;
            line-height: 1.6;
        }

        #instructions p {
            margin: 10px 0;
            color: #aaa;
        }

        .highlight {
            color: #ffcc00;
            font-weight: bold;
        }

        .pulse {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #roomInput {
            padding: 10px;
            margin: 10px;
            font-size: 1rem;
            border-radius: 5px;
            border: 2px solid #00ffea;
            background: rgba(30, 30, 60, 0.8);
            color: white;
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
            flex-direction: column;
        }

        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #endGameScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 300;
            display: none;
            width: 80%;
            max-width: 500px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            .stats, #status {
                font-size: 0.9rem;
                padding: 10px;
            }
            #speedDisplay {
                font-size: 1.4rem;
            }
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen" class="screen">
            <h1>CORRIDA ARCADE</h1>
            <h2>MULTIPLAYER 3D</h2>
            <div id="instructions">
                <p>Controles <span class="highlight">DESKTOP</span>: Direção WASD ou Setas | Acelerar: Espaço | Marchas: W/S</p>
                <p>Controles <span class="highlight">MOBILE</span>: Use os controles na parte inferior da tela</p>
                <p>Objetivo: Complete 3 voltas na pista oval antes do seu oponente!</p>
            </div>
            <input type="text" id="roomInput" placeholder="Digite o ID da sala ou clique em Gerar ID">
            <div>
                <button id="generateIdButton" class="pulse">GERAR ID</button>
                <button id="copyIdButton" class="pulse">COPIAR ID</button>
            </div>
            <button id="startButton" class="pulse">INICIAR CORRIDA</button>
            <button id="offlineButton" class="pulse">JOGAR OFFLINE</button>
        </div>

        <div id="upgradeScreen" class="screen hidden">
            <h1>LOJA DE UPGRADES</h1>
            <h2 id="moneyDisplay">Dinheiro: $300</h2>
            <div class="upgrade-option">
                <h3>MOTOR TURBO</h3>
                <p>Aumenta o torque máximo em 20%</p>
                <p>Custo: $100</p>
                <button class="buy-button" data-upgrade="torque">COMPRAR</button>
            </div>
            <div class="upgrade-option">
                <h3>AERODINÂMICA</h3>
                <p>Aumenta a velocidade máxima em 15%</p>
                <p>Custo: $150</p>
                <button class="buy-button" data-upgrade="speed">COMPRAR</button>
            </div>
            <div class="upgrade-option">
                <h3>TRANSMISSÃO ESPORTIVA</h3>
                <p>Amplia a faixa útil de cada marcha</p>
                <p>Custo: $200</p>
                <button class="buy-button" data-upgrade="gears">COMPRAR</button>
            </div>
            <button id="raceButton">INICIAR CORRIDA</button>
        </div>

        <div id="gameScreen" class="screen hidden">
            <canvas id="gameCanvas"></canvas>
            
            <div class="stats">
                <div>VELOCIDADE: <span id="speedDisplay">0</span> km/h</div>
                <div>MARCHA: <span id="gearDisplay">N</span></div>
                <div>TORQUE:</div>
                <div class="torque-bar">
                    <div class="torque-fill"></div>
                    <div class="torque-optimal"></div>
                </div>
                <div id="lapCounter">VOLTA: 0/3</div>
                <div id="positionDisplay">POSIÇÃO: 1°</div>
            </div>
            
            <div id="status">Pronto para conectar...</div>
            
            <div id="mobileControls">
                <div class="control-group">
                    <div class="control-btn" id="accelerateBtn">A</div>
                    <div class="control-btn" id="brakeBtn">F</div>
                </div>
                
                <div class="control-group">
                    <div id="dPad">
                        <div class="dpad-btn">↑</div>
                        <div class="dpad-btn">←</div>
                        <div class="dpad-btn">↓</div>
                        <div class="dpad-btn">→</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="gear-controls">
                        <div class="control-btn gear-btn" id="gearUpBtn">+</div>
                        <div class="control-btn gear-btn" id="gearDownBtn">-</div>
                    </div>
                    <div class="gear-display" id="mobileGearDisplay">N</div>
                </div>
            </div>
        </div>

        <div id="loadingOverlay" style="display: none;">
            <div class="loader"></div>
            <div id="loadingText">Conectando...</div>
        </div>

        <div id="endGameScreen">
            <h2 id="endGameMessage"></h2>
            <div id="raceResults"></div>
            <button id="rematchBtn">PRÓXIMA CORRIDA</button>
            <button id="exitBtn">SAIR</button>
        </div>
    </div>

    <script>
        // Variáveis globais
        let scene, camera, renderer;
        let localCar, remoteCar, track;
        let smokeParticles = [];
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let players = {};
        let ws = null;
        let peerConnection = null;
        let dataChannel = null;
        let lastMoveSent = 0;
        let startTime = null;
        let finishTimes = {};

        // Configurações do jogo
        const gameConfig = {
            playerId: null,
            roomId: null,
            isOffline: false,
            status: 'waiting',
            gear: 'N',
            speed: 0,
            acceleration: 0,
            torque: 0,
            steering: 0,
            position: new THREE.Vector3(100, 0.5, 0),
            rotation: 0,
            lap: 0,
            lastCheckpoint: 0,
            upgrades: {
                torque: 0,
                speed: 0,
                gears: 0
            },
            money: 300
        };

        // Configurações de marchas
        const gearSettings = {
            'R': { minSpeed: -20, maxSpeed: 0, optimalMin: -14, optimalMax: -7, torqueMultiplier: 0.7 },
            'N': { minSpeed: -10, maxSpeed: 10, optimalMin: 0, optimalMax: 0, torqueMultiplier: 0.1 },            
            '1': { minSpeed: 0, maxSpeed: 120, optimalMin: 16, optimalMax: 20, torqueMultiplier: 1.0 },
            '2': { minSpeed: 0, maxSpeed: 120, optimalMin: 35, optimalMax: 46, torqueMultiplier: 0.9 },
            '3': { minSpeed: 0, maxSpeed: 120, optimalMin: 54, optimalMax: 58, torqueMultiplier: 0.8 },
            '4': { minSpeed: 0, maxSpeed: 120, optimalMin: 70, optimalMax: 78, torqueMultiplier: 0.7 },
            '5': { minSpeed: 0, maxSpeed: 120, optimalMin: 85, optimalMax: 110, torqueMultiplier: 0.6 }
        };

        // Configuração WebRTC
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                {
                    urls: 'turn:turn.speed.cloudflare.com:50000',
                    username: 'd1a7f09155fb30285724a3a056ca2edf17956674aff12909ff133dcec42994b2614cdd0a380a1b65124def1e3d0208543050d14b77d1a7533f9da35893ee2ed9',
                    credential: 'aba9b169546eb6dcc7bfb1cdf34544cf95b5161d602e3b5fa7c8342b2e9802fb'
                },
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ]
        };

        const SERVER_URL = 'wss://heroic-hope-production-bbdc.up.railway.app';

        // Elementos da interface
        const startScreen = document.getElementById('startScreen');
        const upgradeScreen = document.getElementById('upgradeScreen');
        const gameScreen = document.getElementById('gameScreen');
        const startButton = document.getElementById('startButton');
        const offlineButton = document.getElementById('offlineButton');
        const raceButton = document.getElementById('raceButton');
        const generateIdButton = document.getElementById('generateIdButton');
        const copyIdButton = document.getElementById('copyIdButton');
        const roomInput = document.getElementById('roomInput');
        const statusDisplay = document.getElementById('status');
        const speedDisplay = document.getElementById('speedDisplay');
        const gearDisplay = document.getElementById('gearDisplay');
        const mobileGearDisplay = document.getElementById('mobileGearDisplay');
        const torqueFill = document.querySelector('.torque-fill');
        const lapCounter = document.getElementById('lapCounter');
        const positionDisplay = document.getElementById('positionDisplay');
        const moneyDisplay = document.getElementById('moneyDisplay');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const endGameScreen = document.getElementById('endGameScreen');
        const endGameMessage = document.getElementById('endGameMessage');
        const raceResults = document.getElementById('raceResults');
        const rematchBtn = document.getElementById('rematchBtn');
        const exitBtn = document.getElementById('exitBtn');

        // Elementos de controle mobile
        const accelerateBtn = document.getElementById('accelerateBtn');
        const brakeBtn = document.getElementById('brakeBtn');
        const gearUpBtn = document.getElementById('gearUpBtn');
        const gearDownBtn = document.getElementById('gearDownBtn');

        // Inicialização do jogo
        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, -20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            createTrack();
            createLocalCar();
            if (!gameConfig.isOffline) {
                createRemoteCar();
            }

            setupControls();
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        // Criar pista de corrida
        function createTrack() {
            const trackGroup = new THREE.Group();

            const trackGeometry = new THREE.RingGeometry(80, 120, 64, 8);
            const trackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.9,
                metalness: 0.1
            });
            const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
            trackMesh.rotation.x = -Math.PI / 2;
            trackMesh.receiveShadow = true;
            trackGroup.add(trackMesh);

            const borderGeometry = new THREE.TorusGeometry(120, 2, 16, 64);
            const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const outerBorder = new THREE.Mesh(borderGeometry, borderMaterial);
            outerBorder.rotation.x = Math.PI / 2;
            outerBorder.position.y = 0.1;
            outerBorder.receiveShadow = true;
            trackGroup.add(outerBorder);

            const innerBorder = new THREE.Mesh(new THREE.TorusGeometry(80, 2, 16, 64), borderMaterial);
            innerBorder.rotation.x = Math.PI / 2;
            innerBorder.position.y = 0.1;
            innerBorder.receiveShadow = true;
            trackGroup.add(innerBorder);

            const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.2, 12),
                    lineMaterial
                );
                line.position.set(Math.cos(angle) * 100, 0.11, Math.sin(angle) * 100);
                line.rotation.y = -angle;
                line.receiveShadow = true;
                trackGroup.add(line);
            }

            const grassGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
            const grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228822,
                roughness: 1,
                metalness: 0
            });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = -0.1;
            grass.receiveShadow = true;
            trackGroup.add(grass);

            scene.add(trackGroup);
            track = trackGroup;
        }

        // Criar carro local
        function createLocalCar() {
            const carGroup = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3366ff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);

            const hoodGeometry = new THREE.BoxGeometry(2.8, 0.5, 2);
            const hoodMaterial = new THREE.MeshStandardMaterial({ color: 0x2244cc });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.set(0, 0.75, 1);
            hood.castShadow = true;
            carGroup.add(hood);

            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16);
            wheelGeometry.rotateZ(Math.PI / 2);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });

            const wheelPositions = [
                { x: -1.5, y: 0.5, z: 2 },
                { x: 1.5, y: 0.5, z: 2 },
                { x: -1.5, y: 0.5, z: -2 },
                { x: 1.5, y: 0.5, z: -2 }
            ];

            const wheels = [];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);
                wheels.push(wheel);
            });

            const lightGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const lightMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00 });

            const frontLight1 = new THREE.Mesh(lightGeometry, lightMaterial);
            frontLight1.position.set(-0.8, 0.7, 2.5);
            carGroup.add(frontLight1);

            const frontLight2 = new THREE.Mesh(lightGeometry, lightMaterial);
            frontLight2.position.set(0.8, 0.7, 2.5);
            carGroup.add(frontLight2);

            scene.add(carGroup);
            localCar = {
                group: carGroup,
                wheels: wheels,
                position: new THREE.Vector3(100, 0.5, 0),
                rotation: 0,
                targetRotation: 0
            };

            localCar.group.position.copy(localCar.position);
            players[gameConfig.playerId] = {
                x: localCar.position.x,
                z: localCar.position.z,
                rotation: localCar.rotation
            };
        }

        // Criar carro remoto
        function createRemoteCar() {
            const carGroup = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff3366 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);

            const hoodGeometry = new THREE.BoxGeometry(2.8, 0.5, 2);
            const hoodMaterial = new THREE.MeshStandardMaterial({ color: 0xcc2244 });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.set(0, 0.75, 1);
            hood.castShadow = true;
            carGroup.add(hood);

            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16);
            wheelGeometry.rotateZ(Math.PI / 2);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });

            const wheelPositions = [
                { x: -1.5, y: 0.5, z: 2 },
                { x: 1.5, y: 0.5, z: 2 },
                { x: -1.5, y: 0.5, z: -2 },
                { x: 1.5, y: 0.5, z: -2 }
            ];

            const wheels = [];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);
                wheels.push(wheel);
            });

            scene.add(carGroup);
            remoteCar = {
                group: carGroup,
                wheels: wheels,
                position: new THREE.Vector3(90, 0.5, 0),
                rotation: 0
            };

            remoteCar.group.position.copy(remoteCar.position);
            const opponentId = gameConfig.playerId === 0 ? 1 : 0;
            players[opponentId] = {
                x: remoteCar.position.x,
                z: remoteCar.position.z,
                rotation: remoteCar.rotation
            };
        }

        // Configurar controles
        function setupControls() {
            const keys = {};

            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'KeyW' || e.code === 'ArrowUp') shiftGearUp();
                if (e.code === 'KeyS' || e.code === 'ArrowDown') shiftGearDown();
            });

            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            accelerateBtn.addEventListener('touchstart', () => {
                keys['Space'] = true;
                accelerateBtn.style.background = 'rgba(0, 255, 234, 0.5)';
            });

            accelerateBtn.addEventListener('touchend', () => {
                keys['Space'] = false;
                accelerateBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            });

            brakeBtn.addEventListener('touchstart', () => {
                keys['KeyS'] = keys['ArrowDown'] = true;
                brakeBtn.style.background = 'rgba(0, 255, 234, 0.5)';
            });

            brakeBtn.addEventListener('touchend', () => {
                keys['KeyS'] = keys['ArrowDown'] = false;
                brakeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            });

            gearUpBtn.addEventListener('click', shiftGearUp);
            gearDownBtn.addEventListener('click', shiftGearDown);

            const dpadButtons = document.querySelectorAll('.dpad-btn');
            dpadButtons.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const direction = btn.textContent;
                    if (direction === '↑') keys['KeyW'] = keys['ArrowUp'] = true;
                    if (direction === '↓') keys['KeyS'] = keys['ArrowDown'] = true;
                    if (direction === '←') keys['KeyA'] = keys['ArrowLeft'] = true;
                    if (direction === '→') keys['KeyD'] = keys['ArrowRight'] = true;
                    btn.style.background = 'rgba(0, 255, 234, 0.5)';
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const direction = btn.textContent;
                    if (direction === '↑') keys['KeyW'] = keys['ArrowUp'] = false;
                    if (direction === '↓') keys['KeyS'] = keys['ArrowDown'] = false;
                    if (direction === '←') keys['KeyA'] = keys['ArrowLeft'] = false;
                    if (direction === '→') keys['KeyD'] = keys['ArrowRight'] = false;
                    btn.style.background = 'rgba(255, 255, 255, 0.2)';
                });
            });

            function updateControls() {
                gameConfig.acceleration = keys['Space'] ? 1 : 0;
                if (keys['KeyS'] || keys['ArrowDown']) gameConfig.acceleration = -0.5;

                gameConfig.steering = 0;
                if (keys['KeyA'] || keys['ArrowLeft']) gameConfig.steering = 1;
                if (keys['KeyD'] || keys['ArrowRight']) gameConfig.steering = -1;

                updatePhysics();
            }

            setInterval(updateControls, 16);
        }

        // Gerar ID de sala
        function generateRoomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = '';
            for (let i = 0; i < 5; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
        }

        // Conectar ao servidor WebSocket
        function connectToServer() {
            if (!gameConfig.roomId) {
                statusDisplay.textContent = 'Por favor, insira um ID de sala';
                return;
            }

            statusDisplay.textContent = 'Conectando ao servidor...';
            loadingOverlay.style.display = 'flex';

            ws = new WebSocket(SERVER_URL);

            ws.onopen = () => {
                statusDisplay.textContent = 'Aguardando oponente...';
                ws.send(JSON.stringify({ 
                    type: 'join', 
                    roomId: gameConfig.roomId 
                }));
            };

            ws.onerror = (error) => {
                statusDisplay.textContent = 'Erro na conexão. Tente novamente.';
                loadingOverlay.style.display = 'none';
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                statusDisplay.textContent = 'Conexão fechada.';
                loadingOverlay.style.display = 'none';
                gameConfig.status = 'waiting';
            };

            ws.onmessage = async (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'start') {
                        gameConfig.playerId = data.playerId;
                        statusDisplay.textContent = `Você é o jogador ${gameConfig.playerId + 1}`;
                        initPeerConnection();
                        if (gameConfig.playerId === 0) {
                            dataChannel = peerConnection.createDataChannel('gameData');
                            setupDataChannel();
                            const offer = await peerConnection.createOffer();
                            await peerConnection.setLocalDescription(offer);
                            ws.send(JSON.stringify({ type: 'offer', sdp: offer }));
                        }
                    } else if (data.type === 'offer') {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        ws.send(JSON.stringify({ type: 'answer', sdp: answer }));
                    } else if (data.type === 'answer') {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    } else if (data.type === 'ice') {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    } else if (data.type === 'error') {
                        statusDisplay.textContent = `Erro: ${data.message}`;
                        loadingOverlay.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error processing message:', error);
                    statusDisplay.textContent = 'Erro no processamento';
                    loadingOverlay.style.display = 'none';
                }
            };
        }

        // Configurar WebRTC
        function initPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ type: 'ice', candidate: event.candidate }));
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                statusDisplay.textContent = `Estado: ${state}`;
                if (state === 'failed') {
                    statusDisplay.textContent = 'Conexão falhou. Tente novamente.';
                    loadingOverlay.style.display = 'none';
                }
            };

            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel();
            };
        }

        // Configurar canal de dados
        function setupDataChannel() {
            dataChannel.onopen = () => {
                statusDisplay.textContent = 'Conexão P2P estabelecida!';
                startGame();
            };

            dataChannel.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'move') {
                        const opponentId = gameConfig.playerId === 0 ? 1 : 0;
                        if (players[opponentId] && remoteCar) {
                            players[opponentId].x = data.position.x;
                            players[opponentId].z = data.position.z;
                            players[opponentId].rotation = data.position.rotation;
                            remoteCar.position.set(data.position.x, 0.5, data.position.z);
                            remoteCar.group.position.copy(remoteCar.position);
                            remoteCar.rotation = data.position.rotation;
                            remoteCar.group.rotation.y = data.position.rotation;
                            const wheelRotation = data.speed * deltaTime * 2;
                            remoteCar.wheels.forEach(wheel => {
                                wheel.rotation.x += wheelRotation;
                            });
                            if (data.speed > 30 && Math.random() < 0.3) {
                                createSmoke(data.position.x, data.position.z, data.position.rotation, 0xff3366);
                            }
                        }
                    } else if (data.type === 'lap') {
                        const opponentId = gameConfig.playerId === 0 ? 1 : 0;
                        players[opponentId].lap = data.lapCount;
                        if (data.lapCount >= 3 && !gameConfig.status.includes('finished')) {
                            finishTimes[opponentId] = Date.now() - startTime;
                            gameConfig.status = 'opponent_finished';
                            showEndGameScreen(`Jogador ${parseInt(opponentId) + 1} venceu!`);
                        }
                    } else if (data.type === 'restart') {
                        restartGame();
                    }
                } catch (error) {
                    console.error('DataChannel error:', error);
                }
            };
        }

        // Iniciar jogo
        function startGame() {
            players = {};
            gameConfig.lap = 0;
            gameConfig.status = 'playing';
            startTime = Date.now();
            finishTimes = {};

            players[gameConfig.playerId] = {
                x: 100,
                z: 0,
                rotation: 0,
                lap: 0,
                lastCheckpoint: 0
            };

            localCar.position.set(100, 0.5, 0);
            localCar.rotation = 0;
            localCar.targetRotation = 0;
            localCar.group.position.copy(localCar.position);
            localCar.group.rotation.y = localCar.rotation;

            if (!gameConfig.isOffline) {
                const opponentId = gameConfig.playerId === 0 ? 1 : 0;
                players[opponentId] = {
                    x: 90,
                    z: 0,
                    rotation: 0,
                    lap: 0
                };
                remoteCar.position.set(90, 0.5, 0);
                remoteCar.rotation = 0;
                remoteCar.group.position.copy(remoteCar.position);
                remoteCar.group.rotation.y = remoteCar.rotation;
            }

            lapCounter.textContent = 'VOLTA: 0/3';
            positionDisplay.textContent = 'POSIÇÃO: 1°';
            speedDisplay.textContent = '0 km/h';
            gearDisplay.textContent = 'N';
            mobileGearDisplay.textContent = 'N';
            torqueFill.style.width = '0%';
            loadingOverlay.style.display = 'none';
            endGameScreen.style.display = 'none';
        }

        // Reiniciar jogo
        function restartGame() {
            gameConfig.lap = 0;
            gameConfig.status = 'playing';
            startTime = Date.now();
            finishTimes = {};

            players[gameConfig.playerId] = {
                x: 100,
                z: 0,
                rotation: 0,
                lap: 0,
                lastCheckpoint: 0
            };

            localCar.position.set(100, 0.5, 0);
            localCar.rotation = 0;
            localCar.targetRotation = 0;
            localCar.group.position.copy(localCar.position);
            localCar.group.rotation.y = localCar.rotation;

            if (!gameConfig.isOffline) {
                const opponentId = gameConfig.playerId === 0 ? 1 : 0;
                players[opponentId] = {
                    x: 90,
                    z: 0,
                    rotation: 0,
                    lap: 0
                };
                remoteCar.position.set(90, 0.5, 0);
                remoteCar.rotation = 0;
                remoteCar.group.position.copy(remoteCar.position);
                remoteCar.group.rotation.y = remoteCar.rotation;
            }

            lapCounter.textContent = 'VOLTA: 0/3';
            positionDisplay.textContent = 'POSIÇÃO: 1°';
            speedDisplay.textContent = '0 km/h';
            gearDisplay.textContent = 'N';
            mobileGearDisplay.textContent = 'N';
            torqueFill.style.width = '0%';
            endGameScreen.style.display = 'none';
        }

        // Atualizar física do carro
        function updatePhysics() {
            const gear = gearSettings[gameConfig.gear];
            const speed = Math.abs(gameConfig.speed);

            // Calcular torque baseado na velocidade e faixa ideal
            let torqueEfficiency = 10.1;
            if (gameConfig.gear === 'N') {
                torqueEfficiency = gear.torqueMultiplier;
            } else if (gameConfig.gear === 'R') {
                if (gameConfig.speed >= gear.optimalMin && gameConfig.speed <= gear.optimalMax) {
                    torqueEfficiency = gear.torqueMultiplier;
                } else {
                    const distance = Math.min(
                        Math.abs(gameConfig.speed - gear.optimalMin),
                        Math.abs(gameConfig.speed - gear.optimalMax)
                    );
                    torqueEfficiency = gear.torqueMultiplier * Math.max(0.1, 1 - (distance / 10));
                }
            } else {
                if (speed >= gear.optimalMin && speed <= gear.optimalMax) {
                    torqueEfficiency = gear.torqueMultiplier;
                } else {
                    const distance = Math.min(
                        Math.abs(speed - gear.optimalMin),
                        Math.abs(speed - gear.optimalMax)
                    );
                    torqueEfficiency = gear.torqueMultiplier * Math.max(0.1, 1 - (distance / 10));
                }
            }

            // Aplicar upgrades
            const torqueMultiplier = 1 + (gameConfig.upgrades.torque * 0.2);
            const speedMultiplier = 1 + (gameConfig.upgrades.speed * 0.15);
            const gearMultiplier = 1 + (gameConfig.upgrades.gears * 0.25);

            // Calcular aceleração
            let acceleration = gameConfig.acceleration * torqueEfficiency * torqueMultiplier;
            if (gameConfig.gear === 'N') {
                acceleration *= 0.1; // Reduzir aceleração em neutro
            }

            // Atualizar velocidade
            gameConfig.speed += acceleration * deltaTime * 20;
            if (gameConfig.gear === 'R') {
                gameConfig.speed = Math.max(-gear.maxSpeed * speedMultiplier, Math.min(0, gameConfig.speed));
            } else if (gameConfig.gear === 'N') {
                gameConfig.speed *= 0.95;
            } else {
                gameConfig.speed = Math.max(0, Math.min(gear.maxSpeed * speedMultiplier, gameConfig.speed));
            }

            // Aplicar arrasto
            gameConfig.speed *= 0.999;

            // Atualizar torque para exibição
            gameConfig.torque = Math.round(torqueEfficiency * 100);

            // Atualizar direção
            const steeringAmount = gameConfig.steering * deltaTime * 1.5;
            if (Math.abs(gameConfig.speed) > 5) {
                localCar.targetRotation += steeringAmount * Math.sign(gameConfig.speed);
            }

            localCar.rotation += (localCar.targetRotation - localCar.rotation) * 0.1;

            const direction = new THREE.Vector3(
                Math.sin(localCar.rotation),
                0,
                Math.cos(localCar.rotation)
            );

            localCar.position.add(direction.multiplyScalar(gameConfig.speed * deltaTime));
            players[gameConfig.playerId].x = localCar.position.x;
            players[gameConfig.playerId].z = localCar.position.z;
            players[gameConfig.playerId].rotation = localCar.rotation;

            checkLapCompletion();

            localCar.group.position.copy(localCar.position);
            localCar.group.rotation.y = localCar.rotation;

            const wheelRotation = gameConfig.speed * deltaTime * 2;
            localCar.wheels.forEach(wheel => {
                wheel.rotation.x += wheelRotation;
            });

            if (gameConfig.acceleration > 0 && gameConfig.speed > 30 && Math.random() < 0.3) {
                createSmoke(localCar.position.x, localCar.position.z, localCar.rotation, 0x3366ff);
            }

            updateCamera();
            updateUI();

            const now = Date.now();
            if (now - lastMoveSent > 50 && dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ 
                    type: 'move', 
                    playerId: gameConfig.playerId, 
                    position: {
                        x: localCar.position.x,
                        z: localCar.position.z,
                        rotation: localCar.rotation
                    },
                    speed: gameConfig.speed,
                    lapCount: gameConfig.lap
                }));
                lastMoveSent = now;
            }
        }

        // Verificar se completou uma volta
        function checkLapCompletion() {
            if (localCar.position.z > -1 && localCar.position.z < 1 && localCar.position.x > 80 && localCar.position.x < 120) {
                if (gameConfig.lastCheckpoint === 1) {
                    gameConfig.lap++;
                    gameConfig.lastCheckpoint = 0;
                    lapCounter.textContent = `VOLTA: ${gameConfig.lap}/3`;
                    players[gameConfig.playerId].lap = gameConfig.lap;

                    if (dataChannel && dataChannel.readyState === 'open') {
                        dataChannel.send(JSON.stringify({ 
                            type: 'lap', 
                            playerId: gameConfig.playerId,
                            lapCount: gameConfig.lap
                        }));
                    }

                    if (gameConfig.lap >= 3 && !gameConfig.status.includes('finished')) {
                        finishTimes[gameConfig.playerId] = Date.now() - startTime;
                        gameConfig.status = 'finished';
                        showEndGameScreen('Você venceu!');
                        if (dataChannel && dataChannel.readyState === 'open') {
                            dataChannel.send(JSON.stringify({ 
                                type: 'raceOver', 
                                winnerId: gameConfig.playerId
                            }));
                        }
                    }
                }
            } else if (localCar.position.z > 45 || localCar.position.z < -45) {
                gameConfig.lastCheckpoint = 1;
            }
        }

        // Atualizar posição da câmera
        function updateCamera() {
            const carPosition = localCar.position.clone();
            const offset = new THREE.Vector3(
                Math.sin(localCar.rotation) * 15,
                -15,
                Math.cos(localCar.rotation) * 15
            );

            camera.position.copy(carPosition.sub(offset));
            camera.lookAt(localCar.position.x, localCar.position.y + 2, localCar.position.z);
        }

        // Atualizar interface do usuário
        function updateUI() {
            speedDisplay.textContent = Math.abs(Math.round(gameConfig.speed));
            gearDisplay.textContent = gameConfig.gear;
            mobileGearDisplay.textContent = gameConfig.gear;
            torqueFill.style.width = `${gameConfig.torque}%`;
            positionDisplay.textContent = `POSIÇÃO: ${calculatePosition()}°`;
        }

        // Calcular posição na corrida
        function calculatePosition() {
            const opponentId = gameConfig.playerId === 0 ? 1 : 0;
            const playerLaps = gameConfig.lap;
            const opponentLaps = players[opponentId]?.lap || 0;
            if (playerLaps > opponentLaps) return 1;
            if (playerLaps < opponentLaps) return 2;
            return 1; // Empate se número de voltas for igual
        }

        // Criar efeito de fumaça
        function createSmoke(x, z, rotation, color) {
            const smoke = document.createElement('div');
            smoke.className = 'smoke-particle';
            smoke.style.left = `${50 + (x / 4)}%`;
            smoke.style.top = `${50 - (z / 4)}%`;
            smoke.style.backgroundColor = `rgba(${color >> 16}, ${(color >> 8) & 0xff}, ${color & 0xff}, 0.7)`;
            document.getElementById('gameContainer').appendChild(smoke);

            let size = 10;
            let opacity = 0.7;
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 2;

            const animateSmoke = () => {
                size += 0.5;
                opacity -= 0.01;

                if (opacity <= 0) {
                    smoke.remove();
                    return;
                }

                smoke.style.width = `${size}px`;
                smoke.style.height = `${size}px`;
                smoke.style.opacity = opacity;
                smoke.style.transform = `translate(${Math.cos(angle) * speed}px, ${Math.sin(angle) * speed}px)`;

                requestAnimationFrame(animateSmoke);
            };

            animateSmoke();
        }

        // Trocar marcha para cima
        function shiftGearUp() {
            const gears = ['R', 'N', '1', '2', '3', '4', '5'];
            const currentIndex = gears.indexOf(gameConfig.gear);
            if (currentIndex < gears.length - 1) {
                gameConfig.gear = gears[currentIndex + 1];
            }
        }

        // Trocar marcha para baixo
        function shiftGearDown() {
            const gears = ['R', 'N', '1', '2', '3', '4', '5'];
            const currentIndex = gears.indexOf(gameConfig.gear);
            if (currentIndex > 0) {
                gameConfig.gear = gears[currentIndex - 1];
            }
        }

        // Redimensionar a cena
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Exibir tela de fim de jogo
        function showEndGameScreen(message) {
            endGameScreen.style.display = 'block';
            endGameMessage.textContent = message;

            let resultsHTML = '<h3>Resultados:</h3>';
            Object.keys(finishTimes).sort((a, b) => finishTimes[a] - finishTimes[b]).forEach(id => {
                const time = (finishTimes[id] / 1000).toFixed(2);
                resultsHTML += `<p>Jogador ${parseInt(id) + 1}: ${time}s</p>`;
            });

            raceResults.innerHTML = resultsHTML;
            gameConfig.status = 'finished';
        }

        // Fechar conexões
        function closeConnections() {
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // Loop de animação
        function animate() {
            requestAnimationFrame(animate);
            deltaTime = clock.getDelta();

            if (gameConfig.status === 'playing') {
                updatePhysics();
            }

            renderer.render(scene, camera);
        }

        // Eventos de interface
        generateIdButton.addEventListener('click', () => {
            gameConfig.roomId = generateRoomId();
            roomInput.value = gameConfig.roomId;
            statusDisplay.textContent = 'ID gerado!';
        });

        copyIdButton.addEventListener('click', () => {
            roomInput.select();
            document.execCommand('copy');
            statusDisplay.textContent = 'ID copiado!';
        });

        startButton.addEventListener('click', () => {
            gameConfig.isOffline = false;
            gameConfig.roomId = roomInput.value.trim();
            if (!gameConfig.roomId) {
                statusDisplay.textContent = 'Por favor, insira ou gere um ID de sala';
                return;
            }
            connectToServer();
            startScreen.classList.add('hidden');
            upgradeScreen.classList.remove('hidden');
            moneyDisplay.textContent = `Dinheiro: $${gameConfig.money}`;
        });

        offlineButton.addEventListener('click', () => {
            gameConfig.isOffline = true;
            startScreen.classList.add('hidden');
            upgradeScreen.classList.remove('hidden');
            moneyDisplay.textContent = `Dinheiro: $${gameConfig.money}`;
            statusDisplay.textContent = 'Modo Offline';
        });

        raceButton.addEventListener('click', () => {
            upgradeScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            startGame();
        });

        document.querySelectorAll('.buy-button').forEach(button => {
            button.addEventListener('click', (e) => {
                const upgradeType = e.target.dataset.upgrade;
                const cost = upgradeType === 'torque' ? 100 : upgradeType === 'speed' ? 150 : 200;

                if (gameConfig.money >= cost) {
                    gameConfig.money -= cost;
                    gameConfig.upgrades[upgradeType]++;
                    moneyDisplay.textContent = `Dinheiro: $${gameConfig.money}`;
                    e.target.textContent = 'COMPRADO!';
                    e.target.disabled = true;

                    // Desabilitar botões se não houver dinheiro suficiente
                    document.querySelectorAll('.buy-button').forEach(btn => {
                        const btnCost = btn.dataset.upgrade === 'torque' ? 100 : btn.dataset.upgrade === 'speed' ? 150 : 200;
                        btn.disabled = gameConfig.money < btnCost;
                    });
                }
            });
        });

        rematchBtn.addEventListener('click', () => {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ type: 'restart' }));
                restartGame();
            } else {
                statusDisplay.textContent = 'Reconectando...';
                gameConfig.roomId = roomInput.value.trim();
                if (gameConfig.roomId) {
                    connectToServer();
                    upgradeScreen.classList.add('hidden');
                    gameScreen.classList.remove('hidden');
                    startGame();
                }
            }
        });

        exitBtn.addEventListener('click', () => {
            closeConnections();
            gameConfig.status = 'waiting';
            endGameScreen.style.display = 'none';
            startScreen.classList.remove('hidden');
            statusDisplay.textContent = 'Pronto para jogar novamente';
        });

        window.addEventListener('load', initGame);
    </script>
</body>
</html>
