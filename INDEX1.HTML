<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Corrida Arcade Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            transition: opacity 0.5s;
        }

        .hidden {
            display: none;
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffea;
            color: #00ffea;
            letter-spacing: 3px;
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 30px;
            color: #ffcc00;
        }

        button {
            background: #ff3366;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        button:hover {
            background: #ff0066;
            transform: scale(1.05);
        }

        .upgrade-option {
            background: rgba(30, 30, 60, 0.8);
            padding: 15px;
            margin: 10px;
            border-radius: 10px;
            width: 300px;
            text-align: center;
            border: 2px solid #00ffea;
        }

        .upgrade-option h3 {
            color: #ffcc00;
            margin-bottom: 10px;
        }

        .upgrade-option p {
            margin-bottom: 10px;
        }

        .stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffea;
            z-index: 5;
        }

        .stats div {
            margin: 5px 0;
        }

        #speedDisplay {
            font-size: 1.8rem;
            color: #ffcc00;
        }

        #gearDisplay {
            font-size: 1.5rem;
            color: #ff3366;
        }

        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffea;
            z-index: 5;
            font-size: 1.2rem;
            color: #00ffea;
        }

        .torque-bar {
            width: 250px;
            height: 30px;
            background: #333;
            border: 2px solid #00ffea;
            border-radius: 15px;
            margin-top: 10px;
            overflow: hidden;
        }

        .torque-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffcc00, #00ff00);
            width: 0%;
            transition: width 0.1s;
        }

        .torque-optimal {
            position: absolute;
            height: 100%;
            width: 4px;
            background: #00ffea;
            left: 70%;
        }

        #mobileControls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 5;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px;
            color: white;
            font-size: 1.5rem;
            border: 2px solid #00ffea;
            user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            background: rgba(0, 255, 234, 0.3);
        }

        .gear-controls {
            flex-direction: row;
        }

        .gear-btn {
            width: 60px;
            height: 60px;
            margin: 5px;
            background: rgba(255, 51, 102, 0.7);
        }

        .gear-display {
            background: rgba(30, 30, 60, 0.8);
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffcc00;
            border: 2px solid #00ffea;
            margin-top: 10px;
        }

        #dPad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .dpad-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #00ffea;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
        }

        .dpad-btn:nth-child(1) {
            grid-column: 2;
            grid-row: 1;
        }

        .dpad-btn:nth-child(2) {
            grid-column: 1;
            grid-row: 2;
        }

        .dpad-btn:nth-child(3) {
            grid-column: 2;
            grid-row: 2;
        }

        .dpad-btn:nth-child(4) {
            grid-column: 3;
            grid-row: 2;
        }

        .dpad-btn:nth-child(5) {
            grid-column: 2;
            grid-row: 3;
        }

        .smoke-particle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
        }

        #instructions {
            max-width: 600px;
            text-align: center;
            margin: 20px;
            line-height: 1.6;
        }

        #instructions p {
            margin: 10px 0;
            color: #aaa;
        }

        .highlight {
            color: #ffcc00;
            font-weight: bold;
        }

        .pulse {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #roomInput {
            padding: 10px;
            margin: 10px;
            font-size: 1rem;
            border-radius: 5px;
            border: 2px solid #00ffea;
            background: rgba(30, 30, 60, 0.8);
            color: white;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            .stats, #status {
                font-size: 0.9rem;
                padding: 10px;
            }
            #speedDisplay {
                font-size: 1.4rem;
            }
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen" class="screen">
            <h1>CORRIDA ARCADE</h1>
            <h2>MULTIPLAYER 3D</h2>
            <div id="instructions">
                <p>Controles <span class="highlight">DESKTOP</span>: Direção ←↑→↓ | Acelerar: Espaço | Marchas: W/S</p>
                <p>Controles <span class="highlight">MOBILE</span>: Use os controles na parte inferior da tela</p>
                <p>Objetivo: Complete 3 voltas na pista oval antes do seu oponente!</p>
            </div>
            <input type="text" id="roomInput" placeholder="Digite o ID da sala ou deixe em branco para criar uma">
            <button id="startButton" class="pulse">INICIAR CORRIDA</button>
            <button id="offlineButton" class="pulse">JOGAR OFFLINE</button>
        </div>

        <div id="upgradeScreen" class="screen hidden">
            <h1>LOJA DE UPGRADES</h1>
            <div class="upgrade-option">
                <h3>MOTOR TURBO</h3>
                <p>Aumenta o torque máximo em 20%</p>
                <p>Custo: $100</p>
                <button class="buy-button" data-upgrade="torque">COMPRAR</button>
            </div>
            <div class="upgrade-option">
                <h3>AERODINÂMICA</h3>
                <p>Aumenta a velocidade máxima em 15%</p>
                <p>Custo: $150</p>
                <button class="buy-button" data-upgrade="speed">COMPRAR</button>
            </div>
            <div class="upgrade-option">
                <h3>TRANSMISSÃO ESPORTIVA</h3>
                <p>Amplia a faixa útil de cada marcha</p>
                <p>Custo: $200</p>
                <button class="buy-button" data-upgrade="gears">COMPRAR</button>
            </div>
            <button id="raceButton">INICIAR CORRIDA</button>
        </div>

        <div id="gameScreen" class="screen hidden">
            <canvas id="gameCanvas"></canvas>
            
            <div class="stats">
                <div>VELOCIDADE: <span id="speedDisplay">0</span> km/h</div>
                <div>MARCHA: <span id="gearDisplay">N</span></div>
                <div>TORQUE:</div>
                <div class="torque-bar">
                    <div class="torque-fill"></div>
                    <div class="torque-optimal"></div>
                </div>
                <div id="lapCounter">VOLTA: 0/3</div>
            </div>
            
            <div id="status">Aguardando conexão...</div>
            
            <div id="mobileControls">
                <div class="control-group">
                    <div class="control-btn" id="accelerateBtn">A</div>
                    <div class="control-btn" id="brakeBtn">F</div>
                </div>
                
                <div class="control-group">
                    <div id="dPad">
                        <div class="dpad-btn">↑</div>
                        <div class="dpad-btn">←</div>
                        <div class="dpad-btn">↓</div>
                        <div class="dpad-btn">→</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="gear-controls">
                        <div class="control-btn gear-btn" id="gearUpBtn">+</div>
                        <div class="control-btn gear-btn" id="gearDownBtn">-</div>
                    </div>
                    <div class="gear-display" id="mobileGearDisplay">N</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variáveis globais
        let scene, camera, renderer, controls;
        let localCar, remoteCar, track;
        let smokeParticles = [];
        let clock = new THREE.Clock();
        let deltaTime = 0;
        
        // Configurações do jogo
        const gameConfig = {
            playerId: null,
            roomId: null,
            isOffline: false,
            status: 'waiting',
            gear: 'N', // R, N, 1, 2, 3, 4
            speed: 0,
            maxSpeed: 0,
            acceleration: 0,
            torque: 100,
            maxTorque: 100,
            steering: 0,
            position: new THREE.Vector3(0, 0.5, 0),
            rotation: 0,
            lap: 0,
            upgrades: {
                torque: 0,
                speed: 0,
                gears: 0
            },
            money: 300
        };
        
        // Configurações de marchas
        const gearSettings = {
            'N': { minSpeed: -10, maxSpeed: 10, optimal: 0, torqueMultiplier: 0.2 },
            'R': { minSpeed: -30, maxSpeed: 0, optimal: -15, torqueMultiplier: 0.7 },
            '1': { minSpeed: 0, maxSpeed: 40, optimal: 20, torqueMultiplier: 1.0 },
            '2': { minSpeed: 30, maxSpeed: 80, optimal: 55, torqueMultiplier: 0.9 },
            '3': { minSpeed: 70, maxSpeed: 120, optimal: 95, torqueMultiplier: 0.8 },
            '4': { minSpeed: 110, maxSpeed: 160, optimal: 135, torqueMultiplier: 0.7 }
        };
        
        // Elementos da interface
        const startScreen = document.getElementById('startScreen');
        const upgradeScreen = document.getElementById('upgradeScreen');
        const gameScreen = document.getElementById('gameScreen');
        const startButton = document.getElementById('startButton');
        const offlineButton = document.getElementById('offlineButton');
        const raceButton = document.getElementById('raceButton');
        const roomInput = document.getElementById('roomInput');
        const statusDisplay = document.getElementById('status');
        const speedDisplay = document.getElementById('speedDisplay');
        const gearDisplay = document.getElementById('gearDisplay');
        const mobileGearDisplay = document.getElementById('mobileGearDisplay');
        const torqueFill = document.querySelector('.torque-fill');
        const lapCounter = document.getElementById('lapCounter');
        
        // Elementos de controle mobile
        const accelerateBtn = document.getElementById('accelerateBtn');
        const brakeBtn = document.getElementById('brakeBtn');
        const gearUpBtn = document.getElementById('gearUpBtn');
        const gearDownBtn = document.getElementById('gearDownBtn');
        
        // WebSocket
        let ws;
        const wsUrl = 'ws://' + window.location.hostname + ':8080';
        
        // WebRTC
        let peerConnection;
        let dataChannel;
        
        // Inicialização do jogo
        function initGame() {
            // Configurar Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
            
            // Configurar câmera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, -20);
            camera.lookAt(0, 0, 0);
            
            // Configurar renderizador
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // Adicionar iluminação
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Criar pista
            createTrack();
            
            // Criar carros
            createLocalCar();
            if (!gameConfig.isOffline) {
                createRemoteCar();
            }
            
            // Configurar controles
            setupControls();
            
            // Iniciar loop de animação
            animate();
            
            // Lidar com redimensionamento da janela
            window.addEventListener('resize', onWindowResize);
        }
        
        // Criar pista de corrida (maior e estática)
        function createTrack() {
            const trackGroup = new THREE.Group();
            
            // Asfalto (pista maior)
            const trackGeometry = new THREE.RingGeometry(80, 120, 64, 8);
            const trackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.9,
                metalness: 0.1
            });
            const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
            trackMesh.rotation.x = -Math.PI / 2;
            trackMesh.receiveShadow = true;
            trackGroup.add(trackMesh);
            
            // Bordas da pista
            const borderGeometry = new THREE.TorusGeometry(120, 2, 16, 64);
            const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const outerBorder = new THREE.Mesh(borderGeometry, borderMaterial);
            outerBorder.rotation.x = Math.PI / 2;
            outerBorder.position.y = 0.1;
            outerBorder.receiveShadow = true;
            trackGroup.add(outerBorder);
            
            const innerBorder = new THREE.Mesh(new THREE.TorusGeometry(80, 2, 16, 64), borderMaterial);
            innerBorder.rotation.x = Math.PI / 2;
            innerBorder.position.y = 0.1;
            innerBorder.receiveShadow = true;
            trackGroup.add(innerBorder);
            
            // Linhas da pista
            const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.2, 12),
                    lineMaterial
                );
                line.position.set(Math.cos(angle) * 100, 0.11, Math.sin(angle) * 100);
                line.rotation.y = -angle;
                line.receiveShadow = true;
                trackGroup.add(line);
            }
            
            // Grama
            const grassGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
            const grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228822,
                roughness: 1,
                metalness: 0
            });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = -0.1;
            grass.receiveShadow = true;
            trackGroup.add(grass);
            
            scene.add(trackGroup);
            track = trackGroup;
        }
        
        // Criar carro local
        function createLocalCar() {
            const carGroup = new THREE.Group();
            
            // Corpo do carro
            const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3366ff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);
            
            // Capô
            const hoodGeometry = new THREE.BoxGeometry(2.8, 0.5, 2);
            const hoodMaterial = new THREE.MeshStandardMaterial({ color: 0x2244cc });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.set(0, 0.75, 1);
            hood.castShadow = true;
            carGroup.add(hood);
            
            // Rodas
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16);
            wheelGeometry.rotateZ(Math.PI / 2);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            const wheelPositions = [
                { x: -1.5, y: 0.5, z: 2 },
                { x: 1.5, y: 0.5, z: 2 },
                { x: -1.5, y: 0.5, z: -2 },
                { x: 1.5, y: 0.5, z: -2 }
            ];
            
            const wheels = [];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);
                wheels.push(wheel);
            });
            
            // Faróis
            const lightGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const lightMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00 });
            
            const frontLight1 = new THREE.Mesh(lightGeometry, lightMaterial);
            frontLight1.position.set(-0.8, 0.7, 2.5);
            carGroup.add(frontLight1);
            
            const frontLight2 = new THREE.Mesh(lightGeometry, lightMaterial);
            frontLight2.position.set(0.8, 0.7, 2.5);
            carGroup.add(frontLight2);
            
            scene.add(carGroup);
            localCar = {
                group: carGroup,
                wheels: wheels,
                position: new THREE.Vector3(100, 0.5, 0),
                rotation: 0,
                targetRotation: 0
            };
            
            localCar.group.position.copy(localCar.position);
        }
        
        // Criar carro remoto
        function createRemoteCar() {
            const carGroup = new THREE.Group();
            
            // Corpo do carro
            const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff3366 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);
            
            // Capô
            const hoodGeometry = new THREE.BoxGeometry(2.8, 0.5, 2);
            const hoodMaterial = new THREE.MeshStandardMaterial({ color: 0xcc2244 });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.set(0, 0.75, 1);
            hood.castShadow = true;
            carGroup.add(hood);
            
            // Rodas
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16);
            wheelGeometry.rotateZ(Math.PI / 2);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            const wheelPositions = [
                { x: -1.5, y: 0.5, z: 2 },
                { x: 1.5, y: 0.5, z: 2 },
                { x: -1.5, y: 0.5, z: -2 },
                { x: 1.5, y: 0.5, z: -2 }
            ];
            
            const wheels = [];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);
                wheels.push(wheel);
            });
            
            scene.add(carGroup);
            remoteCar = {
                group: carGroup,
                wheels: wheels,
                position: new THREE.Vector3(90, 0.5, 0),
                rotation: 0
            };
            
            remoteCar.group.position.copy(remoteCar.position);
        }
        
        // Configurar controles
        function setupControls() {
            // Controles de teclado
            const keys = {};
            
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                
                // Troca de marchas
                if (e.key === 'w' || e.key === 'W') shiftGearUp();
                if (e.key === 's' || e.key === 'S') shiftGearDown();
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Controles mobile
            accelerateBtn.addEventListener('touchstart', () => {
                keys[' '] = true;
                accelerateBtn.style.background = 'rgba(0, 255, 234, 0.5)';
            });
            
            accelerateBtn.addEventListener('touchend', () => {
                keys[' '] = false;
                accelerateBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            });
            
            brakeBtn.addEventListener('touchstart', () => {
                keys['ArrowDown'] = true;
                brakeBtn.style.background = 'rgba(0, 255, 234, 0.5)';
            });
            
            brakeBtn.addEventListener('touchend', () => {
                keys['ArrowDown'] = false;
                brakeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            });
            
            gearUpBtn.addEventListener('click', shiftGearUp);
            gearDownBtn.addEventListener('click', shiftGearDown);
            
            // Controles de direção mobile
            const dpadButtons = document.querySelectorAll('.dpad-btn');
            dpadButtons.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const direction = btn.textContent;
                    if (direction === '↑') keys['ArrowUp'] = true;
                    if (direction === '↓') keys['ArrowDown'] = true;
                    if (direction === '←') keys['ArrowLeft'] = true;
                    if (direction === '→') keys['ArrowRight'] = true;
                    btn.style.background = 'rgba(0, 255, 234, 0.5)';
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const direction = btn.textContent;
                    if (direction === '↑') keys['ArrowUp'] = false;
                    if (direction === '↓') keys['ArrowDown'] = false;
                    if (direction === '←') keys['ArrowLeft'] = false;
                    if (direction === '→') keys['ArrowRight'] = false;
                    btn.style.background = 'rgba(255, 255, 255, 0.2)';
                });
            });
            
            // Atualizar controles a cada frame
            function updateControls() {
                // Aceleração
                gameConfig.acceleration = keys[' '] ? 1 : 0;
                if (keys['ArrowDown']) gameConfig.acceleration = -0.5;
                
                // Direção
                gameConfig.steering = 0;
                if (keys['ArrowLeft']) gameConfig.steering = 1;
                if (keys['ArrowRight']) gameConfig.steering = -1;
                
                // Atualizar física
                updatePhysics();
            }
            
            // Adicionar ao loop de animação
            setInterval(updateControls, 16);
        }
        
        // Gerar ID de sala
        function generateRoomId() {
            return Math.random().toString(36).substr(2, 9);
        }
        
        // Conectar ao servidor WebSocket
        function connectToServer() {
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                statusDisplay.textContent = "Conectado. Aguardando adversário...";
                // Entrar na sala
                ws.send(JSON.stringify({ type: 'join', roomId: gameConfig.roomId }));
            };
            
            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                
                if (message.type === 'start') {
                    gameConfig.playerId = message.playerId;
                    statusDisplay.textContent = "Jogo iniciado!";
                    startWebRTC();
                } else if (message.type === 'offer') {
                    handleOffer(message);
                } else if (message.type === 'answer') {
                    handleAnswer(message);
                } else if (message.type === 'ice') {
                    handleICECandidate(message);
                }
            };
            
            ws.onerror = (error) => {
                statusDisplay.textContent = "Erro de conexão: " + error.message;
            };
            
            ws.onclose = () => {
                statusDisplay.textContent = "Conexão fechada. Recarregue a página para tentar novamente.";
            };
        }
        
        // Configurar WebRTC
        function startWebRTC() {
            const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
            peerConnection = new RTCPeerConnection(config);
            
            // Canal de dados para comunicação do jogo
            dataChannel = peerConnection.createDataChannel('gameData');
            dataChannel.onopen = () => {
                statusDisplay.textContent = "Conexão P2P estabelecida!";
                setInterval(sendGameState, 100);
            };
            
            dataChannel.onmessage = (event) => {
                const remoteState = JSON.parse(event.data);
                updateRemoteCar(remoteState);
            };
            
            // ICE Candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice',
                        candidate: event.candidate,
                        roomId: gameConfig.roomId
                    }));
                }
            };
            
            // Se somos o primeiro jogador, criamos a offer
            if (gameConfig.playerId === 0) {
                peerConnection.createOffer()
                    .then(offer => peerConnection.setLocalDescription(offer))
                    .then(() => {
                        ws.send(JSON.stringify({
                            type: 'offer',
                            offer: peerConnection.localDescription,
                            roomId: gameConfig.roomId
                        }));
                    });
            }
        }
        
        // Lidar com oferta WebRTC
        function handleOffer(offer) {
            peerConnection.setRemoteDescription(new RTCSessionDescription(offer.offer));
            
            peerConnection.createAnswer()
                .then(answer => peerConnection.setLocalDescription(answer))
                .then(() => {
                    ws.send(JSON.stringify({
                        type: 'answer',
                        answer: peerConnection.localDescription,
                        roomId: gameConfig.roomId
                    }));
                });
        }
        
        // Lidar com resposta WebRTC
        function handleAnswer(answer) {
            peerConnection.setRemoteDescription(new RTCSessionDescription(answer.answer));
        }
        
        // Lidar com candidato ICE
        function handleICECandidate(candidate) {
            peerConnection.addIceCandidate(new RTCIceCandidate(candidate.candidate));
        }
        
        // Enviar estado do jogo para o adversário
        function sendGameState() {
            if (dataChannel && dataChannel.readyState === 'open') {
                const gameState = {
                    position: localCar.position,
                    rotation: localCar.rotation,
                    speed: gameConfig.speed,
                    gear: gameConfig.gear,
                    lap: gameConfig.lap
                };
                dataChannel.send(JSON.stringify(gameState));
            }
        }
        
        // Atualizar carro remoto com dados recebidos
        function updateRemoteCar(remoteState) {
            remoteCar.position.copy(remoteState.position);
            remoteCar.rotation = remoteState.rotation;
            remoteCar.group.position.copy(remoteState.position);
            remoteCar.group.rotation.y = remoteState.rotation;
            
            // Atualizar rotação das rodas
            const wheelRotation = remoteState.speed * deltaTime * 2;
            remoteCar.wheels.forEach(wheel => {
                wheel.rotation.x += wheelRotation;
            });
            
            // Criar efeito de fumaça
            if (remoteState.speed > 30 && Math.random() < 0.3) {
                createSmoke(remoteCar.position.x, remoteCar.position.z, remoteState.rotation, 0xff3366);
            }
        }
        
        // Atualizar física do carro
        function updatePhysics() {
            const gear = gearSettings[gameConfig.gear];
            const speedRatio = Math.abs(gameConfig.speed) / gear.maxSpeed;
            
            // Calcular torque baseado na marcha e velocidade
            let torqueEfficiency = 1.0;
            const optimalSpeed = gear.optimal;
            const speedDifference = Math.abs(Math.abs(gameConfig.speed) - optimalSpeed);
            
            // Reduzir torque quando fora da faixa ideal
            if (speedDifference > 10) {
                torqueEfficiency = Math.max(0.3, 1 - (speedDifference / 50));
            }
            
            // Aplicar upgrades
            const torqueMultiplier = 1 + (gameConfig.upgrades.torque * 0.2);
            const speedMultiplier = 1 + (gameConfig.upgrades.speed * 0.15);
            const gearMultiplier = 1 + (gameConfig.upgrades.gears * 0.25);
            
            // Calcular aceleração (aplicada a todas as marchas)
            let acceleration = gameConfig.acceleration * gear.torqueMultiplier * torqueEfficiency * torqueMultiplier;
            
            // Atualizar velocidade
            gameConfig.speed += acceleration * deltaTime * 20;
            
            // Limitar velocidade baseado na marcha
            if (gameConfig.gear === 'R') {
                gameConfig.speed = Math.max(-gear.maxSpeed * speedMultiplier, Math.min(0, gameConfig.speed));
            } else if (gameConfig.gear === 'N') {
                gameConfig.speed *= 0.95; // Freio natural
            } else {
                gameConfig.speed = Math.max(0, Math.min(gear.maxSpeed * speedMultiplier, gameConfig.speed));
            }
            
            // Aplicar arrasto
            gameConfig.speed *= 0.98;
            
            // Atualizar torque para exibição
            gameConfig.torque = Math.round(torqueEfficiency * 100);
            
            // Atualizar direção
            const steeringAmount = gameConfig.steering * deltaTime * 1.5;
            if (Math.abs(gameConfig.speed) > 5) {
                localCar.targetRotation += steeringAmount * Math.sign(gameConfig.speed);
            }
            
            // Suavizar rotação
            localCar.rotation += (localCar.targetRotation - localCar.rotation) * 0.1;
            
            // Calcular nova posição
            const direction = new THREE.Vector3(
                Math.sin(localCar.rotation),
                0,
                Math.cos(localCar.rotation)
            );
            
            localCar.position.add(direction.multiplyScalar(gameConfig.speed * deltaTime));
            
            // Verificar se completou uma volta
            checkLapCompletion();
            
            // Atualizar posição e rotação do carro
            localCar.group.position.copy(localCar.position);
            localCar.group.rotation.y = localCar.rotation;
            
            // Atualizar rotação das rodas
            const wheelRotation = gameConfig.speed * deltaTime * 2;
            localCar.wheels.forEach(wheel => {
                wheel.rotation.x += wheelRotation;
            });
            
            // Criar efeito de fumaça ao acelerar
            if (gameConfig.acceleration > 0 && gameConfig.speed > 30 && Math.random() < 0.3) {
                createSmoke(localCar.position.x, localCar.position.z, localCar.rotation, 0x3366ff);
            }
            
            // Atualizar câmera
            updateCamera();
            
            // Atualizar interface
            updateUI();
        }
        
        // Verificar se o carro completou uma volta
        function checkLapCompletion() {
            // Sistema de detecção de linha de chegada (ajustado para pista maior)
            if (localCar.position.z > -1 && localCar.position.z < 1) {
                if (localCar.position.x > 80 && localCar.position.x < 120) {
                    gameConfig.lap++;
                    lapCounter.textContent = `VOLTA: ${gameConfig.lap}/3`;
                    
                    // Verificar vitória
                    if (gameConfig.lap >= 3) {
                        statusDisplay.textContent = "VITÓRIA!";
                        gameConfig.status = 'finished';
                    }
                }
            }
        }
        
        // Atualizar posição da câmera
        function updateCamera() {
            const carPosition = localCar.position.clone();
            const offset = new THREE.Vector3(
                Math.sin(localCar.rotation) * 15,
                -15,
                Math.cos(localCar.rotation) * 15
            );
            
            camera.position.copy(carPosition.sub(offset));
            camera.lookAt(localCar.position.x, localCar.position.y + 2, localCar.position.z);
        }
        
        // Atualizar interface do usuário
        function updateUI() {
            // Atualizar velocidade e marcha
            speedDisplay.textContent = Math.abs(Math.round(gameConfig.speed));
            gearDisplay.textContent = gameConfig.gear;
            mobileGearDisplay.textContent = gameConfig.gear;
            
            // Atualizar barra de torque
            torqueFill.style.width = `${gameConfig.torque}%`;
        }
        
        // Criar efeito de fumaça
        function createSmoke(x, z, rotation, color) {
            const smoke = document.createElement('div');
            smoke.className = 'smoke-particle';
            smoke.style.left = `${50 + (x / 4)}%`;
            smoke.style.top = `${50 - (z / 4)}%`;
            smoke.style.backgroundColor = `rgba(${color >> 16}, ${(color >> 8) & 0xff}, ${color & 0xff}, 0.7)`;
            document.getElementById('gameContainer').appendChild(smoke);
            
            // Animação da fumaça
            let size = 10;
            let opacity = 0.7;
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 2;
            
            const animateSmoke = () => {
                size += 0.5;
                opacity -= 0.01;
                
                if (opacity <= 0) {
                    smoke.remove();
                    return;
                }
                
                smoke.style.width = `${size}px`;
                smoke.style.height = `${size}px`;
                smoke.style.opacity = opacity;
                smoke.style.transform = `translate(${Math.cos(angle) * speed}px, ${Math.sin(angle) * speed}px)`;
                
                requestAnimationFrame(animateSmoke);
            };
            
            animateSmoke();
        }
        
        // Trocar marcha para cima
        function shiftGearUp() {
            const gears = ['N', 'R', '1', '2', '3', '4'];
            const currentIndex = gears.indexOf(gameConfig.gear);
            if (currentIndex < gears.length - 1) {
                gameConfig.gear = gears[currentIndex + 1];
            }
        }
        
        // Trocar marcha para baixo
        function shiftGearDown() {
            const gears = ['N', 'R', '1', '2', '3', '4'];
            const currentIndex = gears.indexOf(gameConfig.gear);
            if (currentIndex > 0) {
                gameConfig.gear = gears[currentIndex - 1];
            }
        }
        
        // Redimensionar a cena quando a janela for redimensionada
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Loop de animação
        function animate() {
            requestAnimationFrame(animate);
            deltaTime = clock.getDelta();
            
            // Atualizar física do carro local
            if (gameConfig.status === 'playing') {
                updatePhysics();
            }
            
            // Renderizar cena
            renderer.render(scene, camera);
        }
        
        // Iniciar jogo
        startButton.addEventListener('click', () => {
            gameConfig.isOffline = false;
            gameConfig.roomId = roomInput.value || generateRoomId();
            roomInput.value = gameConfig.roomId;
            connectToServer();
            startScreen.classList.add('hidden');
            upgradeScreen.classList.remove('hidden');
        });
        
        // Iniciar jogo offline
        offlineButton.addEventListener('click', () => {
            gameConfig.isOffline = true;
            startScreen.classList.add('hidden');
            upgradeScreen.classList.remove('hidden');
        });
        
        // Iniciar corrida após upgrades
        raceButton.addEventListener('click', () => {
            upgradeScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameConfig.status = 'playing';
            if (gameConfig.isOffline) {
                statusDisplay.textContent = "Modo Offline";
            }
        });
        
        // Comprar upgrades
        document.querySelectorAll('.buy-button').forEach(button => {
            button.addEventListener('click', (e) => {
                const upgradeType = e.target.dataset.upgrade;
                const cost = upgradeType === 'torque' ? 100 : upgradeType === 'speed' ? 150 : 200;
                
                if (gameConfig.money >= cost) {
                    gameConfig.money -= cost;
                    gameConfig.upgrades[upgradeType]++;
                    e.target.textContent = 'COMPRADO!';
                    e.target.disabled = true;
                }
            });
        });
        
        // Iniciar o jogo quando a página carregar
        window.addEventListener('load', initGame);
    </script>
</body>
</html>