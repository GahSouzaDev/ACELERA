<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>One Racing - Corrida Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Reset CSS */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block; /* Removes extra space below canvas */
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            transition: opacity 0.5s;
            text-align: center;
        }

        .hidden {
            display: none;
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffea;
            color: #00ffea;
            letter-spacing: 3px;
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 30px;
            color: #ffcc00;
        }

        input[type="text"] {
            padding: 12px 20px;
            margin: 10px 0;
            width: 80%;
            max-width: 350px;
            border-radius: 25px;
            border: 2px solid #00ffea;
            background: rgba(30, 30, 60, 0.8);
            color: white;
            font-size: 1.1rem;
            outline: none;
            text-align: center;
        }

        input[type="text"]::placeholder {
            color: #aaa;
        }

        button {
            background: #ff3366;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        button:hover {
            background: #ff0066;
            transform: scale(1.05);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        #instructions {
            max-width: 600px;
            text-align: center;
            margin: 20px;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ffea;
        }

        #instructions p {
            margin: 8px 0;
            color: #ccc;
            font-size: 1rem;
        }

        .highlight {
            color: #ffcc00;
            font-weight: bold;
        }

        .pulse {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        /* Selection Screen (Shop) */
        #selectionScreen {
            padding: 20px;
        }

        #moneyDisplay {
            font-size: 2.5rem;
            color: #00ffea;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #00ffea;
        }

        .section-title {
            font-size: 1.8rem;
            color: #ffcc00;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ffcc00;
            padding-bottom: 5px;
            width: 80%;
            max-width: 600px;
        }

        .selection-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .option-card {
            background: rgba(30, 30, 60, 0.8);
            border: 2px solid #00ffea;
            border-radius: 10px;
            padding: 15px;
            width: 180px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 255, 234, 0.3);
        }

        .option-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(0, 255, 234, 0.7);
        }

        .option-card.selected {
            border-color: #ffcc00;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.8);
            transform: scale(1.05);
        }

        .option-card h3 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .option-card p {
            font-size: 0.9rem;
            color: #ccc;
        }

        .upgrade-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .upgrade-option {
            background: rgba(30, 30, 60, 0.8);
            border: 2px solid #ff3366;
            border-radius: 10px;
            padding: 20px;
            width: 250px;
            text-align: center;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }

        .upgrade-option h3 {
            color: #ffcc00;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        .upgrade-option p {
            font-size: 0.95rem;
            color: #ccc;
            margin-bottom: 15px;
        }

        .upgrade-option .cost {
            font-weight: bold;
            color: #00ffea;
        }

        .betting-section {
            background: rgba(30, 30, 60, 0.8);
            border: 2px solid #00ffea;
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            margin-bottom: 30px;
            width: 80%;
            max-width: 400px;
        }

        .bet-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
        }

        .bet-controls .bet-btn {
            background: #00ffea;
            color: #1a1a2e;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            padding: 0;
            margin: 0 15px;
            font-size: 1.8rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .bet-controls .bet-btn:hover {
            background: #00e0d0;
        }

        .bet-controls span {
            font-size: 2.2rem;
            color: #ffcc00;
            font-weight: bold;
            text-shadow: 0 0 8px #ffcc00;
        }

        /* Game Screen HUD */
        #gameScreen {
            background: transparent;
        }

        .dashboard {
            position: absolute;
            bottom: 20px; /* Base position for desktop */
            right: 20px; /* Base position for desktop */
            width: 250px;
            height: 250px;
            background: radial-gradient(circle at center, rgba(0,0,0,0.8), rgba(0,0,0,0.95));
            border-radius: 50%;
            border: 3px solid #00ffea;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0, 255, 234, 0.5);
        }

        .player-name-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            color: #00ffea;
            font-size: 1.4rem;
            z-index: 5;
            border: 1px solid #00ffea;
            text-shadow: 0 0 5px #00ffea;
        }

        .rpm-gauge {
            position: relative;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .rpm-needle {
            position: absolute;
            width: 2px;
            height: 90px;
            background: red;
            bottom: 50%;
            left: 50%;
            transform-origin: bottom center;
            transition: transform 0.1s linear; /* Smooth needle movement */
            border-radius: 2px 2px 0 0;
        }

        .rpm-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        .rpm-labels span {
            position: absolute;
            color: #fff;
            font-size: 0.9rem;
            font-weight: bold;
            transform: translate(-50%, -50%);
        }

        .rpm-labels span:nth-child(1) { top: 90%; left: 10%; transform: rotate(-135deg); } /* 0 */
        .rpm-labels span:nth-child(2) { top: 95%; left: 30%; transform: rotate(-90deg); } /* 2 */
        .rpm-labels span:nth-child(3) { top: 85%; left: 50%; transform: rotate(-45deg); } /* 4 */
        .rpm-labels span:nth-child(4) { top: 60%; left: 70%; transform: rotate(0deg); } /* 6 */
        .rpm-labels span:nth-child(5) { top: 30%; left: 80%; transform: rotate(45deg); } /* 8 */
        /* More labels can be added for finer granularity */

        .speed-display, .gear-display {
            position: absolute;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 5px #ffcc00;
            background: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #ffcc00;
        }

        .speed-display {
            font-size: 2.5rem;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .gear-display {
            font-size: 2rem;
            top: 65%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #lapCounter, #positionDisplay {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            color: #fff;
            font-size: 1.4rem;
            z-index: 5;
            border: 1px solid #fff;
            text-shadow: 0 0 5px #fff;
        }

        #lapCounter {
            top: 20px;
            right: 20px;
            border-color: #ffcc00;
            color: #ffcc00;
            text-shadow: 0 0 5px #ffcc00;
        }

        #positionDisplay {
            top: 60px; /* Below lap counter */
            right: 20px;
            border-color: #00ffea;
            color: #00ffea;
            text-shadow: 0 0 5px #00ffea;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #ffcc00;
            z-index: 5;
            font-size: 1.2rem;
            color: #ffcc00;
            white-space: nowrap;
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            z-index: 5;
            pointer-events: auto; /* Re-enable interaction for buttons */
        }

        .mobile-only { /* Hidden on desktop */
            display: none;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 8px;
            color: white;
            font-size: 1.8rem;
            border: 2px solid #00ffea;
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 0 10px rgba(0, 255, 234, 0.3);
        }

        .control-btn:active {
            background: rgba(0, 255, 234, 0.3);
        }

        .control-btn.active { /* For pressed state */
            background: rgba(0, 255, 234, 0.6);
            box-shadow: 0 0 15px rgba(0, 255, 234, 0.8);
        }

        .gear-controls {
            flex-direction: row;
        }

        .gear-btn {
            width: 60px;
            height: 60px;
            margin: 5px;
            background: rgba(255, 51, 102, 0.7);
            border-color: #ff3366;
        }

        .gear-btn:active {
            background: rgba(255, 51, 102, 0.9);
        }

        .mobile-gear-display {
            background: rgba(30, 30, 60, 0.8);
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffcc00;
            border: 2px solid #00ffea;
            margin-top: 10px;
        }
        
        .dpad-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
        }

        .dpad-btn {
            width: 55px;
            height: 55px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #00ffea;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            border-radius: 8px; /* Slightly rounded for dpad */
            box-shadow: 0 0 8px rgba(0, 255, 234, 0.2);
        }

        .dpad-btn:active, .dpad-btn.active {
            background: rgba(0, 255, 234, 0.5);
            box-shadow: 0 0 12px rgba(0, 255, 234, 0.6);
        }

        /* Layout for D-Pad buttons */
        .dpad-btn:nth-child(1) { grid-column: 2; grid-row: 1; } /* Up */
        .dpad-btn:nth-child(2) { grid-column: 1; grid-row: 2; } /* Left */
        .dpad-btn:nth-child(3) { grid-column: 3; grid-row: 2; } /* Right */

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
            flex-direction: column;
        }

        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loadingText {
            font-size: 1.5rem;
            color: #fff;
        }

        /* End Game Screen */
        #endGameScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 300;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(0, 255, 234, 0.8);
        }

        #endGameMessage {
            font-size: 2.5rem;
            color: #00ffea;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffea;
        }

        #raceResults {
            margin-top: 20px;
            font-size: 1.2rem;
            line-height: 1.6;
        }

        #raceResults h3 {
            color: #ffcc00;
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        #raceResults p {
            margin: 5px 0;
            color: #eee;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; letter-spacing: 2px; }
            h2 { font-size: 1.5rem; }
            input[type="text"] { font-size: 1rem; padding: 10px 15px; max-width: 300px; }
            button { padding: 12px 25px; font-size: 1.1rem; }
            #instructions { font-size: 0.9rem; padding: 10px; margin: 10px auto; }
            #instructions p { font-size: 0.9rem; }

            #moneyDisplay { font-size: 1.8rem; }
            .section-title { font-size: 1.4rem; }
            .option-card { width: 150px; padding: 10px; }
            .option-card h3 { font-size: 1.1rem; }
            .option-card p { font-size: 0.8rem; }
            .upgrade-option { padding: 15px; margin: 10px; width: 200px; }
            .upgrade-option h3 { font-size: 1.3rem; }
            .upgrade-option p { font-size: 0.9rem; }
            .betting-section { padding: 15px; max-width: 300px; }
            .bet-controls .bet-btn { width: 35px; height: 35px; font-size: 1.5rem; margin: 0 10px; }
            .bet-controls span { font-size: 1.8rem; }

            .player-name-hud { font-size: 1.2rem; top: 10px; left: 10px; padding: 5px 10px; }
            #lapCounter, #positionDisplay { font-size: 1.2rem; padding: 5px 10px; }
            #lapCounter { top: 10px; right: 10px; }
            #positionDisplay { top: 40px; right: 10px; }
            #status { font-size: 1rem; padding: 8px 15px; bottom: 5px; }

            .dashboard {
                width: 180px; height: 180px;
                bottom: unset; /* Remove bottom */
                right: 10px;
                top: 70px; /* Position below top-right HUD elements */
                border-width: 2px;
                box-shadow: 0 0 15px rgba(0, 255, 234, 0.5);
            }
            .rpm-gauge { width: 140px; height: 140px; }
            .rpm-needle { height: 60px; }
            .speed-display { font-size: 1.8rem; }
            .gear-display { font-size: 1.5rem; }

            .mobile-only { /* Show mobile controls on small screens */
                display: flex;
            }

            #mobileControls {
                bottom: 5px;
                padding: 0 5px;
            }
            .control-btn { width: 60px; height: 60px; font-size: 1.5rem; margin: 5px; }
            .gear-btn { width: 50px; height: 50px; font-size: 1.2rem; }
            .dpad-btn { width: 45px; height: 45px; font-size: 1.2rem; }

            #endGameScreen { padding: 20px; }
            #endGameMessage { font-size: 2rem; }
            #raceResults h3 { font-size: 1.5rem; }
            #raceResults p { font-size: 1rem; }
        }

        @media (min-width: 769px) {
            .mobile-only {
                display: none !important; /* Hide mobile controls on larger screens */
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen" class="screen">
            <h1>ONE RACING</h1>
            <h2>MULTIPLAYER 3D</h2>
            <div id="instructions">
                <p>Controles <span class="highlight">DESKTOP</span>: Acelerar: Espaço | Frear/Ré: S | Marcha Acima: W | Marcha Abaixo: Q | Direção: A/D</p>
                <p>Controles <span class="highlight">MOBILE</span>: Use os botões na tela</p>
                <p>Objetivo: Complete 3 voltas na pista antes do seu oponente!</p>
            </div>
            <input type="text" id="playerNameInput" placeholder="Seu Nome (max 15)" maxlength="15" value="Jogador">
            <input type="text" id="roomInput" placeholder="ID da Sala ou Gerar ID">
            <div class="button-group">
                <button id="generateIdButton" class="pulse">GERAR ID</button>
                <button id="copyIdButton" class="pulse">COPIAR ID</button>
            </div>
            <button id="startButton" class="pulse">INICIAR MULTIPLAYER</button>
            <button id="offlineButton" class="pulse">JOGAR OFFLINE</button>
        </div>

        <div id="selectionScreen" class="screen hidden">
            <h1>PREPARAR PARA CORRIDA</h1>
            <h2 id="moneyDisplay">Dinheiro: $300</h2>

            <div class="section-title">SELECIONAR CARRO</div>
            <div class="selection-options" id="carSelectionOptions">
                <!-- Carros serão injetados aqui -->
            </div>

            <div class="section-title">SELECIONAR PISTA</div>
            <div class="selection-options" id="trackSelectionOptions">
                <!-- Pistas serão injetadas aqui -->
            </div>

            <div class="section-title">LOJA DE UPGRADES</div>
            <div class="upgrade-container">
                <div class="upgrade-option">
                    <h3>MOTOR TURBO</h3>
                    <p>Aumenta o torque máximo em 20%</p>
                    <p>Custo: <span class="cost">$100</span></p>
                    <button class="buy-button" data-upgrade="torque">COMPRAR</button>
                </div>
                <div class="upgrade-option">
                    <h3>AERODINÂMICA</h3>
                    <p>Aumenta a velocidade máxima em 15%</p>
                    <p>Custo: <span class="cost">$150</span></p>
                    <button class="buy-button" data-upgrade="speed">COMPRAR</button>
                </div>
                <div class="upgrade-option">
                    <h3>TRANSMISSÃO ESPORTIVA</h3>
                    <p>Amplia a faixa útil de cada marcha</p>
                    <p>Custo: <span class="cost">$200</span></p>
                    <button class="buy-button" data-upgrade="gears">COMPRAR</button>
                </div>
            </div>
            
            <div class="betting-section">
                <div class="section-title">APOSTA POR CORRIDA</div>
                <div class="bet-controls">
                    <button class="bet-btn" id="betDecrease">-</button>
                    <span>$<span id="betValue">0</span></span>
                    <button class="bet-btn" id="betIncrease">+</button>
                </div>
            </div>

            <button id="raceButton">INICIAR CORRIDA</button>
        </div>

        <div id="gameScreen" class="screen hidden">
            <canvas id="gameCanvas"></canvas>
            
            <div class="dashboard">
                <div class="player-name-hud" id="playerNameHud">Nome</div>
                <div class="rpm-gauge">
                    <div class="rpm-needle" id="rpmNeedle"></div>
                    <div class="rpm-labels">
                        <span>0</span><span>2</span><span>4</span><span>6</span><span>8</span>
                    </div>
                    <div class="speed-display" id="speedDisplay">0</div>
                    <div class="gear-display" id="gearDisplay">N</div>
                </div>
            </div>
            
            <div id="status"></div>
            <div id="lapCounter">VOLTA: 0/3</div>
            <div id="positionDisplay">POSIÇÃO: 1°</div>

            <div id="mobileControls" class="mobile-only">
                <div class="control-group">
                    <button class="control-btn accelerate-btn" id="accelerateBtn">Acelerar</button>
                    <button class="control-btn brake-btn" id="brakeBtn">Frear</button>
                </div>
                
                <div class="control-group">
                    <button class="control-btn dpad-btn" id="turnLeftBtn">←</button>
                    <button class="control-btn dpad-btn" id="turnRightBtn">→</button>
                </div>
                
                <div class="control-group">
                    <button class="control-btn gear-btn" id="gearUpBtn">▲</button>
                    <button class="control-btn gear-btn" id="gearDownBtn">▼</button>
                </div>
            </div>
        </div>

        <div id="loadingOverlay" class="screen hidden">
            <div class="loader"></div>
            <div id="loadingText">Conectando...</div>
        </div>

        <div id="endGameScreen" class="screen hidden">
            <h2 id="endGameMessage"></h2>
            <div id="raceResults"></div>
            <button id="rematchBtn">PRÓXIMA CORRIDA</button>
            <button id="exitBtn">SAIR</button>
        </div>
    </div>

    <script type="module">
        // Three.js JSM modules included directly
        // CatmullRomCurve3
        class CatmullRomCurve3 {
            constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
                this.points = points;
                this.closed = closed;
                this.curveType = curveType;
                this.tension = tension;
            }

            getPoint(t, optionalTarget = new THREE.Vector3()) {
                const points = this.points;
                const l = points.length;

                if (!l) {
                    return null;
                }

                const p = (l - (this.closed ? 0 : 1)) * t;
                let intPoint = Math.floor(p);
                const weight = p - intPoint;

                if (this.closed) {
                    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
                } else {
                    // clamp the points to return
                    if (weight === 0 && intPoint === l - 1) {
                        return optionalTarget.copy(points[intPoint]);
                    }

                    if (intPoint < 0) {
                        return optionalTarget.copy(points[0]);
                    }

                    if (intPoint > l - 1) {
                        return optionalTarget.copy(points[l - 1]);
                    }
                }

                let p0 = points[(intPoint - 1 + l) % l];
                const p1 = points[intPoint % l];
                let p2 = points[(intPoint + 1 + l) % l];
                let p3 = points[(intPoint + 2 + l) % l];

                if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
                    // DECOMPOSE this into steps.
                    //
                    // D3 has centripetal catmull rom:
                    // http://www.centripetalcatmullrom.com/
                    // given an array of points, the line passing through the points will have less overshoot and will thus look more natural
                    //
                    // reference article for "Centripetal Catmull Rom"
                    // http://www.cemyuksel.com/courses/common/catmullrom.pdf
                    //
                    // The tension parameter is not used in the D3 implementation, now you can control the tension
                    // The curve passes through the points, so p1 and p2 are the points for the segment
                    // P(t) = (t^3 - 2t^2 + t)P(0)/2 + (-t^3 + t^2)P(1)/2 + (t^3 - t^2)P(2)/2 + (t^3 - t^2)P(3)/2
                    // where P(0), P(1), P(2), P(3) are the four points involved

                    const ti = 0.5; // for centripetal and chordal
                    const pow = this.curveType === 'centripetal' ? 0.5 : 1.0;
                    let d1 = p0.distanceTo(p1) ** pow;
                    let d2 = p1.distanceTo(p2) ** pow;
                    let d3 = p2.distanceTo(p3) ** pow;

                    if (d1 < 1e-4) d1 = 1e-4; // prevents division by zero
                    if (d2 < 1e-4) d2 = 1e-4;
                    if (d3 < 1e-4) d3 = 1e-4;

                    const tmp = p1.clone();
                    tmp.multiplyScalar(2 * d1 ** 2 + d1 * d2 + d2 ** 2);
                    p0 = p0.clone().multiplyScalar(d2 ** 2);
                    p3 = p3.clone().multiplyScalar(d1 ** 2);
                    p0.add(tmp).sub(p3).multiplyScalar(1 / (2 * d1 * d2 + d2 ** 2)); // P0 is the tangent vector at P1
                    p2.multiplyScalar(2 * d3 ** 2 + d2 * d3 + d2 ** 2);
                    p1.multiplyScalar(d2 ** 2);
                    p0.add(tmp).sub(p3).multiplyScalar(1 / (2 * d2 * d3 + d3 ** 2)); // P3 is the tangent vector at P2

                    // Catmull-Rom from Wikipedia (uniform_tension=0.5)
                    // P(t) = ((2t^3 - 3t^2 + 1)P1 + (-2t^3 + 3t^2)P2 + (t^3 - 2t^2 + t)T1 + (t^3 - t^2)T2) / 2
                    // where T1, T2 are tangent vectors at P1, P2
                    // P1, P2 are the two points for this segment
                    // P0, P3 are the two points for neighboring segments
                    // T1 = (P2 - P0) * tension (tension=0.5 makes it Catmull-Rom)
                    // T2 = (P3 - P1) * tension

                    const v0 = p0;
                    const v1 = p1;
                    const v2 = p2;
                    const v3 = p3;

                    const x = CatmullRomCurve3.interpolate(v0.x, v1.x, v2.x, v3.x, weight, ti);
                    const y = CatmullRomCurve3.interpolate(v0.y, v1.y, v2.y, v3.y, weight, ti);
                    const z = CatmullRomCurve3.interpolate(v0.z, v1.z, v2.z, v3.z, weight, ti);

                    optionalTarget.set(x, y, z);
                } else if (this.curveType === 'catmullrom') {
                    const v0 = p0;
                    const v1 = p1;
                    const v2 = p2;
                    const v3 = p3;

                    const x = CatmullRomCurve3.interpolate(v0.x, v1.x, v2.x, v3.x, weight, this.tension);
                    const y = CatmullRomCurve3.interpolate(v0.y, v1.y, v2.y, v3.y, weight, this.tension);
                    const z = CatmullRomCurve3.interpolate(v0.z, v1.z, v2.z, v3.z, weight, this.tension);

                    optionalTarget.set(x, y, z);
                } else { // linear or bezier or whatever
                    console.warn('THREE.CatmullRomCurve3: "curveType" not recognized.');
                }

                return optionalTarget;
            }

            getPoints(divisions = 5) {
                const points = [];
                for (let i = 0; i <= divisions; i++) {
                    points.push(this.getPoint(i / divisions));
                }
                return points;
            }

            getTangent(t, optionalTarget = new THREE.Vector3()) {
                const points = this.points;
                const l = points.length;

                if (!l) {
                    return null;
                }

                const p = (l - (this.closed ? 0 : 1)) * t;
                let intPoint = Math.floor(p);
                const weight = p - intPoint;

                if (this.closed) {
                    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
                } else {
                    if (weight === 0 && intPoint === l - 1) {
                        intPoint = l - 2;
                        weight = 1;
                    } else if (weight === 0 && intPoint === 0) {
                        intPoint = 0;
                        weight = 0;
                    }
                    if (intPoint < 0) {
                        return optionalTarget.copy(points[0]).sub(points[1]).normalize();
                    }
                    if (intPoint > l - 1) {
                        return optionalTarget.copy(points[l - 1]).sub(points[l - 2]).normalize();
                    }
                }

                const p0 = points[(intPoint - 1 + l) % l];
                const p1 = points[intPoint % l];
                const p2 = points[(intPoint + 1 + l) % l];
                const p3 = points[(intPoint + 2 + l) % l];

                const v0 = p0;
                const v1 = p1;
                const v2 = p2;
                const v3 = p3;

                const x = CatmullRomCurve3.interpolateTangent(v0.x, v1.x, v2.x, v3.x, weight, this.tension);
                const y = CatmullRomCurve3.interpolateTangent(v0.y, v1.y, v2.y, v3.y, weight, this.tension);
                const z = CatmullRomCurve3.interpolateTangent(v0.z, v1.z, v2.z, v3.z, weight, this.tension);

                return optionalTarget.set(x, y, z).normalize();
            }

            getTangentAt(u, optionalTarget) {
                const t = this.getU(u);
                return this.getTangent(t, optionalTarget);
            }

            getU(u) {
                return u;
            }

            // Static method for interpolation (reused from previous Three.js versions)
            static interpolate(p0, p1, p2, p3, t, tension) {
                const v0 = (p2 - p0) * tension;
                const v1 = (p3 - p1) * tension;
                const t2 = t * t;
                const t3 = t * t2;
                return (2 * t3 - 3 * t2 + 1) * p1 + (t3 - 2 * t2 + t) * v0 + (-2 * t3 + 3 * t2) * p2 + (t3 - t2) * v1;
            }

            static interpolateTangent(p0, p1, p2, p3, t, tension) {
                const v0 = (p2 - p0) * tension;
                const v1 = (p3 - p1) * tension;
                const t2 = t * t;
                return (6 * t2 - 6 * t) * p1 + (3 * t2 - 4 * t + 1) * v0 + (-6 * t2 + 6 * t) * p2 + (3 * t2 - 2 * t) * v1;
            }
        }

        // TubeGeometry
        class TubeGeometry extends THREE.BufferGeometry {
            constructor(path, tubularSegments = 64, radius = 1, radiusSegments = 8, closed = false) {
                super();
                this.type = 'TubeGeometry';

                this.parameters = {
                    path: path,
                    tubularSegments: tubularSegments,
                    radius: radius,
                    radiusSegments: radiusSegments,
                    closed: closed
                };

                const frames = path.computeFrenetFrames(tubularSegments, closed);

                // Buffer data
                const tangents = frames.tangents;
                const normals = frames.normals;
                const binormals = frames.binormals;

                const vertex = new THREE.Vector3();
                const normal = new THREE.Vector3();
                const uv = new THREE.Vector2();

                const vertices = [];
                const normalsVec = [];
                const uvs = [];
                const indices = [];

                // Helper variables
                const P = new THREE.Vector3();
                const N = new THREE.Vector3(); // Corrected: N should be a Vector3, not just a type

                // Loop along path segments
                for (let i = 0; i < tubularSegments; i++) {
                    path.getPointAt(i / tubularSegments, P);

                    const tangent = tangents[i];
                    const normalLocal = normals[i];
                    const binormalLocal = binormals[i];

                    // Loop around tube cross section
                    for (let j = 0; j <= radiusSegments; j++) {
                        const v = j / radiusSegments * Math.PI * 2;
                        const sin = Math.sin(v);
                        const cos = Math.cos(v);

                        // Calculate position
                        normal.copy(normalLocal).multiplyScalar(cos);
                        normal.add(binormalLocal.clone().multiplyScalar(sin));
                        normal.normalize();

                        vertex.copy(P);
                        vertex.add(normal.clone().multiplyScalar(radius));

                        vertices.push(vertex.x, vertex.y, vertex.z);
                        normalsVec.push(normal.x, normal.y, normal.z);
                        uvs.push(i / tubularSegments, j / radiusSegments);
                    }
                }

                // Indices
                for (let i = 0; i < tubularSegments; i++) {
                    for (let j = 0; j < radiusSegments; j++) {
                        const i0 = i * (radiusSegments + 1) + j;
                        const i1 = i0 + 1;
                        const i2 = (i + 1) * (radiusSegments + 1) + j;
                        const i3 = i2 + 1;

                        indices.push(i0, i2, i1);
                        indices.push(i1, i2, i3);
                    }
                }

                this.setIndex(indices);
                this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                this.setAttribute('normal', new THREE.Float32BufferAttribute(normalsVec, 3));
                this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            }
        }

        // Add computeFrenetFrames to THREE.Curve prototype (since Three.js r128 might not have it directly on THREE.Curve)
        // This is necessary for TubeGeometry to work as expected.
        if (THREE.Curve.prototype.computeFrenetFrames === undefined) {
            THREE.Curve.prototype.computeFrenetFrames = function(segments, closed) {
                // helper variables
                const normal = new THREE.Vector3();
                const tangents = [];
                const normals = [];
                const binormals = [];

                const vec = new THREE.Vector3();
                const mat = new THREE.Matrix4();

                // compute the tangent vectors for each segment on the path
                for (let i = 0; i <= segments; i++) {
                    tangents.push(this.getTangent(i / segments));
                }

                // get initial normal for the first segment
                normals[0] = new THREE.Vector3();
                binormals[0] = new THREE.Vector3();

                let n = new THREE.Vector3(0, 0, 1);
                let t = tangents[0];
                let up = new THREE.Vector3(0, 1, 0);
                let cross = new THREE.Vector3();

                // check if the first tangent is parallel to the default `up` vector
                // if so, use another `up` vector
                if (t.y > 0.999) {
                    t = new THREE.Vector3(0, 1, 0);
                    up = new THREE.Vector3(0, 0, 1);
                }
                
                cross.crossVectors(up, t).normalize();
                normal.crossVectors(t, cross).normalize();
                binormals[0].crossVectors(t, normal).normalize();
                normals[0].copy(normal);

                // compute the normals and binormals for each segment on the path
                for (let i = 1; i <= segments; i++) {
                    normals[i] = new THREE.Vector3();
                    binormals[i] = new THREE.Vector3();

                    n.copy(normals[i - 1]);
                    t.copy(tangents[i]);

                    mat.makeRotationAxis(vec.crossVectors(tangents[i - 1], t).normalize(), vec.angleTo(t));
                    n.applyMatrix4(mat);

                    normals[i].copy(n);
                    binormals[i].crossVectors(t, n).normalize();
                }

                // If the curve is closed, postprocess the frames
                if (closed) {
                    let normal = new THREE.Vector3();
                    let binormal = new THREE.Vector3();

                    const t0 = tangents[0];
                    const tn = tangents[segments];

                    const n0 = normals[0];
                    const nn = normals[segments];

                    const b0 = binormals[0];
                    const bn = binormals[segments];

                    const dot = t0.dot(tn);
                    if (Math.abs(dot) !== 1) {
                        normal.crossVectors(t0, tn).normalize();
                        if (normal.lengthSq() > 1e-4) { // Avoid issues with parallel tangents
                            // Calculate twist angle
                            const theta = Math.acos(n0.dot(nn) / (n0.length() * nn.length()));
                            const sign = (normal.dot(t0) > 0) ? 1 : -1;
                            const twist = theta * sign;

                            for (let i = 0; i <= segments; i++) {
                                // apply twist
                                mat.makeRotationAxis(tangents[i], twist * (i / segments));
                                normals[i].applyMatrix4(mat);
                                binormals[i].applyMatrix4(mat);
                            }
                        }
                    }
                }

                return {
                    tangents: tangents,
                    normals: normals,
                    binormals: binormals
                };
            };
        }


        // Global game configuration
        const gameConfig = {
            playerId: null,
            roomId: null,
            isOffline: false,
            status: 'waiting', // 'waiting', 'playing', 'finished'
            gear: 'N',
            speed: 0, // km/h
            accelerationInput: 0, // -1 (brake/reverse), 0 (coast), 1 (accelerate)
            steeringInput: 0, // -1 (right), 0 (straight), 1 (left)
            currentTorque: 0, // Current RPM
            selectedCarId: 'basicSportsCar',
            selectedTrackId: 'ovalTrack',
            upgrades: {
                torque: 0, // Level of torque upgrade
                speed: 0,  // Level of top speed upgrade
                gears: 0   // Level of gear efficiency/optimal range upgrade
            },
            money: 300,
            betAmount: 0,
            playerName: 'Jogador',
            opponentName: 'Oponente',
            // Car physics properties
            accelerationFactor: 0.1, // Base acceleration multiplier
            maxSpeedBase: 120, // Base max speed in km/h
            torqueMultiplierBase: 100, // Base torque multiplier
            handlingFactor: 0.05, // Base handling/steering sensitivity
        };

        const gearSettings = {
            'R': { name: 'R', minSpeed: 0, maxSpeed: 30, optimalMin: 0, optimalMax: 20, torqueMultiplier: 0.6 },
            'N': { name: 'N', minSpeed: 0, maxSpeed: 10, optimalMin: 0, optimalMax: 0, torqueMultiplier: 0.1 },            
            '1': { name: '1', minSpeed: 0, maxSpeed: 60, optimalMin: 10, optimalMax: 40, torqueMultiplier: 1.0 },
            '2': { name: '2', minSpeed: 20, maxSpeed: 100, optimalMin: 40, optimalMax: 70, torqueMultiplier: 0.9 },
            '3': { name: '3', minSpeed: 50, maxSpeed: 150, optimalMin: 70, optimalMax: 110, torqueMultiplier: 0.8 },
            '4': { name: '4', minSpeed: 90, maxSpeed: 200, optimalMin: 110, optimalMax: 160, torqueMultiplier: 0.7 },
            '5': { name: '5', minSpeed: 140, maxSpeed: 250, optimalMin: 160, optimalMax: 220, torqueMultiplier: 0.6 }
        };

        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                {
                    urls: 'turn:turn.speed.cloudflare.com:50000',
                    username: 'd1a7f09155fb30285724a3a056ca2edf17956674aff12909ff133dcec42994b2614cdd0a380a1b65124def1e3d0208543050d14b77d1a7533f9da35893ee2ed9',
                    credential: 'aba9b169546eb6dcc7bfb1cdf34544cf95b5161d602e3b5fa7c8342b2e9802fb'
                },
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ]
        };

        const SERVER_URL = 'wss://heroic-hope-production-bbdc.up.railway.app'; // Replace with your actual server URL


        // --- UTILS ---
        function generateRoomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = '';
            for (let i = 0; i < 5; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
        }

        function isMobileDevice() {
            return (typeof window.orientation !== 'undefined') || (navigator.userAgent.indexOf('IEMobile') !== -1);
        }

        function createNameTagCanvas(name, colorHex) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48;
            const font = `bold ${fontSize}px Arial`;

            context.font = font;
            const textWidth = context.measureText(name).width;

            canvas.width = textWidth + 20; // Add some padding
            canvas.height = fontSize + 10;

            // Redraw with new dimensions
            context.font = font;
            context.fillStyle = `rgb(${(colorHex >> 16) & 0xFF}, ${(colorHex >> 8) & 0xFF}, ${colorHex & 0xFF})`; // Use car color for text
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(name, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true; // Important for dynamic textures
            return texture;
        }

        function createNameTagSprite(name, color) {
            const texture = createNameTagCanvas(name, color);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 5, 1); // Scale sprite to be visible
            sprite.position.set(0, 3, 0); // Position above the car
            return sprite;
        }

        // --- SOUND MANAGER ---
        class SoundManager {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.sounds = {}; // Stores decoded audio buffers
                this.engineSoundSource = null;
                this.engineGain = null;
                this.enginePanner = null;
                this.engineFilter = null; 
                this.enginePlaying = false;
                this.isReady = false;
                this._lastSkidPlayTime = 0;
            }

            async init() {
                if (this.isReady) return;
                try {
                    await this.audioContext.resume();
                    this.engineGain = this.audioContext.createGain();
                    this.enginePanner = this.audioContext.createStereoPanner();
                    this.engineFilter = this.audioContext.createBiquadFilter(); // This line creates the filter

                    this.engineFilter.type = 'lowpass';
                    this.engineFilter.frequency.value = 5000;

                    this.engineGain.connect(this.engineFilter);
                    this.engineFilter.connect(this.enginePanner);
                    this.enginePanner.connect(this.audioContext.destination);
                    this.engineGain.gain.value = 0.0;

                    this.generateSyntheticSounds();
                    this.isReady = true;
                } catch (e) {
                    console.error('Failed to initialize AudioContext:', e);
                }
            }

            async loadSound(name, url) {
                if (!this.isReady) await this.init();
                return new Promise((resolve, reject) => {
                    fetch(url)
                        .then(response => response.arrayBuffer())
                        .then(data => this.audioContext.decodeAudioData(data))
                        .then(buffer => {
                            this.sounds[name] = buffer;
                            resolve();
                        })
                        .catch(error => {
                            console.error(`Error loading sound ${name}:`, error);
                            reject(error);
                        });
                });
            }

            playSound(name, loop = false, volume = 1.0) {
                if (!this.isReady || !this.sounds[name]) return null;

                const source = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();

                source.buffer = this.sounds[name];
                source.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                gainNode.gain.value = volume;
                source.loop = loop;
                source.start();

                return source;
            }

            generateSyntheticSounds() {
                const sampleRate = this.audioContext.sampleRate;

                // Gear Shift Sound
                const gearShiftDuration = 0.2;
                const gearShiftBuffer = this.audioContext.createBuffer(1, sampleRate * gearShiftDuration, sampleRate);
                const gearShiftData = gearShiftBuffer.getChannelData(0);
                for (let i = 0; i < gearShiftData.length; i++) {
                    const t = i / sampleRate;
                    gearShiftData[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-25 * t);
                }
                this.sounds['gear_shift'] = gearShiftBuffer;

                // Skid Sound (short burst of white noise)
                const skidDuration = 0.5;
                const skidBuffer = this.audioContext.createBuffer(1, sampleRate * skidDuration, sampleRate);
                const skidData = skidBuffer.getChannelData(0);
                for (let i = 0; i < skidData.length; i++) {
                    skidData[i] = (Math.random() * 2 - 1) * Math.exp(-4 * (i / skidData.length));
                }
                this.sounds['skid'] = skidBuffer;
            }

            startEngineSound() {
                if (!this.isReady || this.enginePlaying) return;

                this.engineSoundSource = this.audioContext.createOscillator();
                this.engineSoundSource.type = 'sawtooth';
                this.engineSoundSource.frequency.value = 80;

                this.engineSoundSource.connect(this.engineGain);
                this.engineSoundSource.start(0);
                this.enginePlaying = true;
                this.engineGain.gain.setValueAtTime(0.0, this.audioContext.currentTime);
                this.engineGain.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.5);
            }

            updateEngineSound(speed, currentGear, maxSpeed, engineRPM) {
                if (!this.enginePlaying || !this.engineSoundSource || !this.engineFilter) return;

                const minFreq = 80;
                const maxFreq = 600;
                const rpmRatio = Math.min(1.0, Math.max(0.0, engineRPM / 8000));
                this.engineSoundSource.frequency.value = minFreq + (maxFreq - minFreq) * rpmRatio;

                const minVolume = 0.1;
                const maxVolume = 0.6;
                this.engineGain.gain.value = minVolume + (maxVolume - minVolume) * rpmRatio;

                const minCutoff = 800;
                const maxCutoff = 4000;
                this.engineFilter.frequency.value = minCutoff + (maxCutoff - minCutoff) * rpmRatio; // This is the corrected line

                this.enginePanner.pan.value = Math.sin(this.audioContext.currentTime * 0.5) * 0.1;
            }

            stopEngineSound() {
                if (this.engineSoundSource && this.enginePlaying) {
                    this.engineGain.gain.linearRampToValueAtTime(0.0, this.audioContext.currentTime + 0.3);
                    setTimeout(() => {
                        if (this.engineSoundSource) {
                            this.engineSoundSource.stop();
                            this.engineSoundSource.disconnect();
                            this.engineSoundSource = null;
                        }
                    }, 300);
                    this.enginePlaying = false;
                }
            }

            playGearShift() {
                if (this.isReady) {
                    this.playSound('gear_shift', false, 0.6);
                }
            }

            playSkid() {
                if (this.isReady) {
                    if (!this._lastSkidPlayTime || (this.audioContext.currentTime - this._lastSkidPlayTime > 0.1)) {
                        this.playSound('skid', false, 0.4);
                        this._lastSkidPlayTime = this.audioContext.currentTime;
                    }
                }
            }
        }

        // --- CAR FACTORY ---
        class CarFactory {
            constructor() {
                this.cars = {
                    basicSportsCar: {
                        id: 'basicSportsCar',
                        name: 'Esportivo Básico',
                        accelerationFactor: 0.1,
                        maxSpeedBase: 180,
                        torqueMultiplierBase: 80,
                        handlingFactor: 0.05,
                        color: 0x3366ff,
                        startPosition: new THREE.Vector3(100, 0.5, 0),
                        createModel: this.createBasicSportsCarModel
                    },
                    muscleCar: {
                        id: 'muscleCar',
                        name: 'Muscle Car',
                        accelerationFactor: 0.15, // Better acceleration
                        maxSpeedBase: 160, // Lower top speed
                        torqueMultiplierBase: 120, // High torque
                        handlingFactor: 0.03, // Worse handling
                        color: 0xff3300,
                        startPosition: new THREE.Vector3(100, 0.5, 0),
                        createModel: this.createMuscleCarModel
                    },
                    formulaCar: {
                        id: 'formulaCar',
                        name: 'Fórmula Racer',
                        accelerationFactor: 0.2, // Best acceleration
                        maxSpeedBase: 220, // High top speed
                        torqueMultiplierBase: 100, // Balanced torque
                        handlingFactor: 0.07, // Best handling
                        color: 0x00ff00,
                        startPosition: new THREE.Vector3(100, 0.5, 0),
                        createModel: this.createFormulaCarModel
                    }
                };
            }

            getCarById(id) {
                return this.cars[id] || null;
            }

            getAllCars() {
                return Object.values(this.cars);
            }

            createBasicSportsCarModel(carColor) {
                const carGroup = new THREE.Group();
                const color = carColor !== undefined ? carColor : 0x3366ff;

                const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;
                carGroup.add(body);

                const hoodGeometry = new THREE.BoxGeometry(2.8, 0.5, 2);
                const hoodMaterial = new THREE.MeshStandardMaterial({ color: color });
                const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
                hood.position.set(0, 0.75, 1);
                hood.castShadow = true;
                carGroup.add(hood);

                const cabinGeometry = new THREE.BoxGeometry(2.5, 0.8, 2.5);
                const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
                cabin.position.set(0, 1.2, -0.5);
                cabin.castShadow = true;
                carGroup.add(cabin);

                const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16);
                wheelGeometry.rotateZ(Math.PI / 2);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });

                const wheelPositions = [
                    { x: -1.5, y: 0.5, z: 2 },
                    { x: 1.5, y: 0.5, z: 2 },
                    { x: -1.5, y: 0.5, z: -2 },
                    { x: 1.5, y: 0.5, z: -2 }
                ];

                const wheels = [];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(pos.x, pos.y, pos.z);
                    wheel.castShadow = true;
                    carGroup.add(wheel);
                    wheels.push(wheel);
                });

                return { group: carGroup, wheels: wheels };
            }

            createMuscleCarModel(carColor) {
                const carGroup = new THREE.Group();
                const color = carColor !== undefined ? carColor : 0xff3300;

                // Main body - more blocky
                const bodyGeometry = new THREE.BoxGeometry(3.5, 1.2, 5.5);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.6;
                body.castShadow = true;
                carGroup.add(body);

                // Raised hood
                const hoodGeometry = new THREE.BoxGeometry(3, 0.8, 2.5);
                const hoodMaterial = new THREE.MeshStandardMaterial({ color: color });
                const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
                hood.position.set(0, 1.3, 1.5);
                hood.castShadow = true;
                carGroup.add(hood);

                // Cabin - smaller, further back
                const cabinGeometry = new THREE.BoxGeometry(3, 1, 2);
                const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
                cabin.position.set(0, 1.6, -1.0);
                cabin.castShadow = true;
                carGroup.add(cabin);

                // Wheels - slightly larger, wider
                const wheelGeometry = new THREE.CylinderGeometry(0.6, 0.6, 1, 16);
                wheelGeometry.rotateZ(Math.PI / 2);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });

                const wheelPositions = [
                    { x: -1.8, y: 0.6, z: 2.2 },
                    { x: 1.8, y: 0.6, z: 2.2 },
                    { x: -1.8, y: 0.6, z: -2.2 },
                    { x: 1.8, y: 0.6, z: -2.2 }
                ];

                const wheels = [];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(pos.x, pos.y, pos.z);
                    wheel.castShadow = true;
                    carGroup.add(wheel);
                    wheels.push(wheel);
                });

                return { group: carGroup, wheels: wheels };
            }

            createFormulaCarModel(carColor) {
                const carGroup = new THREE.Group();
                const color = carColor !== undefined ? carColor : 0x00ff00;

                // Main chassis
                const chassisGeometry = new THREE.BoxGeometry(1.5, 0.7, 4.0);
                const chassisMaterial = new THREE.MeshStandardMaterial({ color: color });
                const chassis = new THREE.Mesh(chassisGeometry, chassisMaterial);
                chassis.position.y = 0.35;
                chassis.castShadow = true;
                carGroup.add(chassis);

                // Nose cone
                const noseGeometry = new THREE.BoxGeometry(1, 0.5, 2);
                const noseMaterial = new THREE.MeshStandardMaterial({ color: color });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(0, 0.5, 3);
                nose.castShadow = true;
                carGroup.add(nose);

                // Cockpit
                const cockpitGeometry = new THREE.BoxGeometry(1.2, 0.8, 1.5);
                const cockpitMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                cockpit.position.set(0, 0.8, -0.5);
                cockpit.castShadow = true;
                carGroup.add(cockpit);

                // Wheels - exposed, wider stance
                const wheelGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.4, 16);
                wheelGeometry.rotateZ(Math.PI / 2);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });

                const wheelPositions = [
                    { x: -1.2, y: 0.35, z: 2.5 },
                    { x: 1.2, y: 0.35, z: 2.5 },
                    { x: -1.2, y: 0.35, z: -1.5 },
                    { x: 1.2, y: 0.35, z: -1.5 }
                ];

                const wheels = [];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(pos.x, pos.y, pos.z);
                    wheel.castShadow = true;
                    carGroup.add(wheel);
                    wheels.push(wheel);
                });

                return { group: carGroup, wheels: wheels };
            }
        }

        const carFactory = new CarFactory();
        const CARS = carFactory.getAllCars();

        // --- TRACK FACTORY ---
        class OvalTrack {
            constructor() {
                this.id = 'ovalTrack';
                this.name = 'Pista Oval Clássica';
                this.startPosition = new THREE.Vector3(100, 0.5, 0);
                this.frictionZones = [
                    // These are conceptual zones, actual friction check will be in main.js
                    { type: 'circular_band', innerRadius: 120, outerRadius: 500, frictionMultiplier: 0.2 }, // Grass outside track
                    { type: 'circle', radius: 80, frictionMultiplier: 0.2 } // Grass inside track
                ];
                this.checkpoints = [
                    // Checkpoints are defined relative to the track's coordinate system
                    { position: new THREE.Vector3(100, 0.5, 0), radius: 20, isStartFinish: true, nextCheckpointIndex: 1 }, // Start/finish line
                    { position: new THREE.Vector3(-100, 0.5, 0), radius: 20, isStartFinish: false, nextCheckpointIndex: 0 } // Opposite side of oval
                ];
            }

            createModel() {
                const trackGroup = new THREE.Group();

                // Track surface (asphalt) - RingGeometry for the oval shape
                const trackGeometry = new THREE.RingGeometry(80, 120, 64); // Inner radius, outer radius, segments
                const trackMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333, // Dark grey for asphalt
                    roughness: 0.7,
                    metalness: 0.1
                });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.rotation.x = -Math.PI / 2; // Rotate to lie flat
                trackMesh.receiveShadow = true;
                trackGroup.add(trackMesh);

                // Track borders (red and white)
                const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red for borders
                const innerBorderGeometry = new THREE.TorusGeometry(80, 2, 16, 64);
                const innerBorder = new THREE.Mesh(innerBorderGeometry, borderMaterial);
                innerBorder.rotation.x = Math.PI / 2;
                innerBorder.position.y = 0.1;
                trackGroup.add(innerBorder);

                const outerBorderGeometry = new THREE.TorusGeometry(120, 2, 16, 64);
                const outerBorder = new THREE.Mesh(outerBorderGeometry, borderMaterial);
                outerBorder.rotation.x = Math.PI / 2;
                outerBorder.position.y = 0.1;
                outerBorder.receiveShadow = true;
                trackGroup.add(outerBorder);

                // Center line (white dashes)
                const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const line = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.2, 12),
                        lineMaterial
                    );
                    line.position.set(Math.cos(angle) * 100, 0.11, Math.sin(angle) * 100);
                    line.rotation.y = -angle; // Rotate lines to be perpendicular to the track
                    line.receiveShadow = true;
                    trackGroup.add(line);
                }

                // Grass/Terrain surrounding the track
                const grassGeometry = new THREE.PlaneGeometry(1000, 1000); // Large plane for the ground
                const grassMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228822, // Green for grass
                    roughness: 1, // Rough surface
                    metalness: 0
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.y = -0.1; // Below the track
                grass.receiveShadow = true;
                trackGroup.add(grass);

                return trackGroup;
            }
        }

        class CircuitTrack {
            constructor() {
                this.id = 'circuitTrack';
                this.name = 'Circuito Desafiador';

                this.pathPoints = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(100, 0, 0),
                    new THREE.Vector3(120, 0, 50),
                    new THREE.Vector3(80, 0, 120),
                    new THREE.Vector3(0, 0, 150),
                    new THREE.Vector3(-80, 0, 120),
                    new THREE.Vector3(-120, 0, 50),
                    new THREE.Vector3(-100, 0, 0),
                    new THREE.Vector3(-120, 0, -50),
                    new THREE.Vector3(-80, 0, -120),
                    new THREE.Vector3(0, 0, -150),
                    new THREE.Vector3(80, 0, -120),
                    new THREE.Vector3(120, 0, -50),
                    new THREE.Vector3(100, 0, 0)
                ];
                this.curve = new CatmullRomCurve3(this.pathPoints, true);

                this.checkpoints = [
                    { position: new THREE.Vector3(0, 0.5, 0), radius: 15, isStartFinish: true, nextCheckpointIndex: 1 },
                    { position: new THREE.Vector3(80, 0.5, 80), radius: 15, isStartFinish: false, nextCheckpointIndex: 2 },
                    { position: new THREE.Vector3(0, 0.5, 150), radius: 15, isStartFinish: false, nextCheckpointIndex: 3 },
                    { position: new THREE.Vector3(-80, 0.5, 80), radius: 15, isStartFinish: false, nextCheckpointIndex: 4 },
                    { position: new THREE.Vector3(-80, 0.5, -80), radius: 15, isStartFinish: false, nextCheckpointIndex: 5 },
                    { position: new THREE.Vector3(0, 0.5, -150), radius: 15, isStartFinish: false, nextCheckpointIndex: 6 },
                    { position: new THREE.Vector3(80, 0.5, -80), radius: 15, isStartFinish: false, nextCheckpointIndex: 0 },
                ];
                this.startPosition = this.checkpoints[0].position.clone();
            }

            createModel() {
                const trackGroup = new THREE.Group();
                const roadWidth = 20;
                const borderHeight = 1;

                const tubularSegments = 500;
                const radiusSegments = 8;
                const closed = true;

                const tubularPath = new CatmullRomCurve3(this.pathPoints, true); // Use CatmullRomCurve3 for TubeGeometry path

                const trackGeometry = new TubeGeometry(tubularPath, tubularSegments, roadWidth / 2, radiusSegments, closed);
                const trackMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.7,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.receiveShadow = true;
                trackGroup.add(trackMesh);

                const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

                const innerBorderOffsetCurve = new CatmullRomCurve3(
                    this.curve.getPoints(tubularSegments).map(p => {
                        const tangent = this.curve.getTangent(this.curve.getU(p)).normalize();
                        const normal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0,1,0)).normalize();
                        return new THREE.Vector3().addVectors(p, normal.multiplyScalar(roadWidth / 2 + 1));
                    }), true
                );
                const innerBorderGeometry = new TubeGeometry(innerBorderOffsetCurve, tubularSegments, 0.5, radiusSegments, closed);
                const innerBorderMesh = new THREE.Mesh(innerBorderGeometry, borderMaterial);
                innerBorderMesh.position.y = borderHeight / 2 + 0.1;
                innerBorderMesh.receiveShadow = true;
                trackGroup.add(innerBorderMesh);

                const outerBorderOffsetCurve = new CatmullRomCurve3(
                    this.curve.getPoints(tubularSegments).map(p => {
                        const tangent = this.curve.getTangent(this.curve.getU(p)).normalize();
                        const normal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0,1,0)).normalize().negate();
                        return new THREE.Vector3().addVectors(p, normal.multiplyScalar(roadWidth / 2 + 1));
                    }), true
                );
                const outerBorderGeometry = new TubeGeometry(outerBorderOffsetCurve, tubularSegments, 0.5, radiusSegments, closed);
                const outerBorderMesh = new THREE.Mesh(outerBorderGeometry, borderMaterial);
                outerBorderMesh.position.y = borderHeight / 2 + 0.1;
                outerBorderMesh.receiveShadow = true;
                trackGroup.add(outerBorderMesh);

                const startLineGeometry = new THREE.PlaneGeometry(roadWidth + 2, 1);
                const startLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                const startLineMesh = new THREE.Mesh(startLineGeometry, startLineMaterial);
                startLineMesh.rotation.x = -Math.PI / 2;
                startLineMesh.position.copy(this.curve.getPointAt(0));
                startLineMesh.position.y = 0.06;
                const startTangent = this.curve.getTangentAt(0);
                const startAngle = Math.atan2(startTangent.x, startTangent.z);
                startLineMesh.rotation.z = startAngle;
                trackGroup.add(startLineMesh);

                const grassGeometry = new THREE.PlaneGeometry(1000, 1000);
                const grassMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228822,
                    roughness: 1,
                    metalness: 0
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.y = -0.1;
                grass.receiveShadow = true;
                trackGroup.add(grass);

                this.frictionZones = [
                    { type: 'curve_proximity', curve: this.curve, roadWidth: roadWidth, frictionMultiplier: 0.3 }
                ];

                return trackGroup;
            }
        }

        class TrackFactory {
            constructor() {
                this.tracks = {
                    ovalTrack: new OvalTrack(),
                    circuitTrack: new CircuitTrack(),
                };
            }

            getTrackById(id) {
                return this.tracks[id] || null;
            }

            getAllTracks() {
                return Object.values(this.tracks);
            }
        }

        const trackFactory = new TrackFactory();
        const TRACKS = trackFactory.getAllTracks();


        // --- UI MANAGER ---
        // UI Elements
        const uiElements = {}; // Will store all DOM elements

        function initUI() {
            // Get all necessary DOM elements
            uiElements.startScreen = document.getElementById('startScreen');
            uiElements.selectionScreen = document.getElementById('selectionScreen');
            uiElements.gameScreen = document.getElementById('gameScreen');
            uiElements.loadingOverlay = document.getElementById('loadingOverlay');
            uiElements.endGameScreen = document.getElementById('endGameScreen');

            uiElements.playerNameInput = document.getElementById('playerNameInput');
            uiElements.roomInput = document.getElementById('roomInput');
            uiElements.generateIdButton = document.getElementById('generateIdButton');
            uiElements.copyIdButton = document.getElementById('copyIdButton');
            uiElements.startButton = document.getElementById('startButton');
            uiElements.offlineButton = document.getElementById('offlineButton');

            uiElements.moneyDisplay = document.getElementById('moneyDisplay');
            uiElements.carSelectionOptions = document.getElementById('carSelectionOptions');
            uiElements.trackSelectionOptions = document.getElementById('trackSelectionOptions');
            uiElements.buyButtons = document.querySelectorAll('.buy-button');
            uiElements.betDecrease = document.getElementById('betDecrease');
            uiElements.betValue = document.getElementById('betValue');
            uiElements.betIncrease = document.getElementById('betIncrease');
            uiElements.raceButton = document.getElementById('raceButton');

            uiElements.playerNameHud = document.getElementById('playerNameHud');
            uiElements.rpmNeedle = document.getElementById('rpmNeedle');
            uiElements.speedDisplay = document.getElementById('speedDisplay');
            uiElements.gearDisplay = document.getElementById('gearDisplay');
            uiElements.statusDisplay = document.getElementById('status');
            uiElements.lapCounter = document.getElementById('lapCounter');
            uiElements.positionDisplay = document.getElementById('positionDisplay');
            uiElements.loadingText = document.getElementById('loadingText');

            uiElements.endGameMessage = document.getElementById('endGameMessage');
            uiElements.raceResults = document.getElementById('raceResults');
            uiElements.rematchBtn = document.getElementById('rematchBtn');
            uiElements.exitBtn = document.getElementById('exitBtn');

            // Mobile Controls
            uiElements.mobileControls = document.getElementById('mobileControls');
            uiElements.accelerateBtn = document.getElementById('accelerateBtn');
            uiElements.brakeBtn = document.getElementById('brakeBtn');
            uiElements.gearUpBtn = document.getElementById('gearUpBtn');
            uiElements.gearDownBtn = document.getElementById('gearDownBtn');
            uiElements.turnLeftBtn = document.getElementById('turnLeftBtn');
            uiElements.turnRightBtn = document.getElementById('turnRightBtn');
            
            // Show/hide mobile controls based on device
            if (isMobileDevice()) {
                uiElements.mobileControls.style.display = 'flex';
            } else {
                uiElements.mobileControls.style.display = 'none';
            }

            // Event Listeners
            uiElements.generateIdButton.addEventListener('click', () => gameCallbacks.onGenerateRoomId());
            uiElements.copyIdButton.addEventListener('click', () => gameCallbacks.onCopyRoomId());
            uiElements.startButton.addEventListener('click', () => gameCallbacks.onMultiplayerStart());
            uiElements.offlineButton.addEventListener('click', () => gameCallbacks.onOfflineStart());
            uiElements.raceButton.addEventListener('click', () => gameCallbacks.onRaceStart());

            uiElements.buyButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    gameCallbacks.onBuyUpgrade(e.target.dataset.upgrade);
                });
            });

            uiElements.betIncrease.addEventListener('click', () => gameCallbacks.onBetIncrease());
            uiElements.betDecrease.addEventListener('click', () => gameCallbacks.onBetDecrease());

            uiElements.rematchBtn.addEventListener('click', () => gameCallbacks.onRematch());
            uiElements.exitBtn.addEventListener('click', () => gameCallbacks.onExitGame());

            // Mobile control event listeners
            uiElements.accelerateBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameCallbacks.onAccelerateStart(); }, { passive: false });
            uiElements.accelerateBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameCallbacks.onAccelerateEnd(); }, { passive: false });
            uiElements.brakeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameCallbacks.onBrakeStart(); }, { passive: false });
            uiElements.brakeBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameCallbacks.onBrakeEnd(); }, { passive: false });
            uiElements.gearUpBtn.addEventListener('click', () => gameCallbacks.onGearUp());
            uiElements.gearDownBtn.addEventListener('click', () => gameCallbacks.onGearDown());
            uiElements.turnLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameCallbacks.onTurnLeftStart(); }, { passive: false });
            uiElements.turnLeftBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameCallbacks.onTurnLeftEnd(); }, { passive: false });
            uiElements.turnRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameCallbacks.onTurnRightStart(); }, { passive: false });
            uiElements.turnRightBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameCallbacks.onTurnRightEnd(); }, { passive: false });
            
            // Populate car and track selection
            populateCarSelection();
            populateTrackSelection();
        }

        function showScreen(screenId) {
            uiElements.startScreen.classList.add('hidden');
            uiElements.selectionScreen.classList.add('hidden');
            uiElements.gameScreen.classList.add('hidden');
            uiElements.loadingOverlay.classList.add('hidden');
            uiElements.endGameScreen.classList.add('hidden');

            document.getElementById(screenId).classList.remove('hidden');
        }

        function updateHUD(speed, gear, currentLap, totalLaps, position, rpm) {
            uiElements.speedDisplay.textContent = `${Math.round(Math.abs(speed))} km/h`;
            uiElements.gearDisplay.textContent = gear;
            uiElements.lapCounter.textContent = `VOLTA: ${currentLap}/${totalLaps}`;
            uiElements.positionDisplay.textContent = `POSIÇÃO: ${position}°`;

            // Update RPM needle
            const rpmAngle = (rpm / 8000) * 270 - 135; // Map 0-8000 RPM to -135 to +135 degrees (270 total range)
            uiElements.rpmNeedle.style.transform = `translateX(-50%) rotate(${rpmAngle}deg)`;
        }

        function updateMoneyDisplay() {
            uiElements.moneyDisplay.textContent = `Dinheiro: $${gameConfig.money}`;
            updateUpgradeButtonStates();
        }

        function updateUpgradeButtonStates() {
            uiElements.buyButtons.forEach(button => {
                const upgradeType = button.dataset.upgrade;
                const currentLevel = gameConfig.upgrades[upgradeType];
                const cost = getUpgradeCost(upgradeType, currentLevel);
                const maxLevel = 3; // Example: Max level for upgrades

                if (currentLevel >= maxLevel) {
                    button.textContent = 'MÁXIMO';
                    button.disabled = true;
                    button.style.backgroundColor = '#555';
                } else if (gameConfig.money < cost) {
                    button.textContent = `COMPRAR ($${cost})`;
                    button.disabled = true;
                    button.style.backgroundColor = '#555';
                } else {
                    button.textContent = `COMPRAR ($${cost})`;
                    button.disabled = false;
                    button.style.backgroundColor = '#ff3366';
                }
            });
        }

        function getUpgradeCost(upgradeType, currentLevel) {
            switch (upgradeType) {
                case 'torque': return 100 * (currentLevel + 1);
                case 'speed': return 150 * (currentLevel + 1);
                case 'gears': return 200 * (currentLevel + 1);
                default: return 0;
            }
        }

        function updateBetValue(amount) {
            uiElements.betValue.textContent = amount;
        }

        function populateCarSelection() {
            uiElements.carSelectionOptions.innerHTML = '';
            carFactory.getAllCars().forEach(car => {
                const card = document.createElement('div');
                card.classList.add('option-card');
                card.dataset.carId = car.id;
                card.innerHTML = `
                    <h3>${car.name}</h3>
                    <p>Aceleração: ${car.accelerationFactor * 100}%</p>
                    <p>Velocidade Máx: ${car.maxSpeedBase} km/h</p>
                    <p>Manejo: ${car.handlingFactor * 100}%</p>
                `;
                card.addEventListener('click', () => {
                    gameCallbacks.onCarSelected(car.id);
                    document.querySelectorAll('.option-card[data-car-id]').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                });
                uiElements.carSelectionOptions.appendChild(card);
            });
            // Select default car
            const defaultCarCard = document.querySelector(`.option-card[data-car-id="${gameConfig.selectedCarId}"]`);
            if (defaultCarCard) {
                defaultCarCard.classList.add('selected');
            }
        }

        function populateTrackSelection() {
            uiElements.trackSelectionOptions.innerHTML = '';
            trackFactory.getAllTracks().forEach(track => {
                const card = document.createElement('div');
                card.classList.add('option-card');
                card.dataset.trackId = track.id;
                card.innerHTML = `
                    <h3>${track.name}</h3>
                    <p>Tipo: ${track.id === 'ovalTrack' ? 'Oval' : 'Circuito'}</p>
                `;
                card.addEventListener('click', () => {
                    gameCallbacks.onTrackSelected(track.id);
                    document.querySelectorAll('.option-card[data-track-id]').forEach(t => t.classList.remove('selected'));
                    card.classList.add('selected');
                });
                uiElements.trackSelectionOptions.appendChild(card);
            });
            // Select default track
            const defaultTrackCard = document.querySelector(`.option-card[data-track-id="${gameConfig.selectedTrackId}"]`);
            if (defaultTrackCard) {
                defaultTrackCard.classList.add('selected');
            }
        }

        // --- MAIN GAME LOGIC ---
        let scene, camera, renderer;
        let localCar = null;
        let remoteCar = null;
        let currentTrackModel = null;
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let players = {};
        let ws = null;
        let peerConnection = null;
        let dataChannel = null;
        let lastMoveSentTime = 0;
        let startTime = null;
        let finishTimes = {};
        let soundManager = new SoundManager();
        let keys = {}; // Keyboard input state

        // Callbacks for UI Manager to interact with game logic
        const gameCallbacks = {
            onGenerateRoomId: () => {
                gameConfig.roomId = generateRoomId();
                uiElements.roomInput.value = gameConfig.roomId;
                uiElements.statusDisplay.textContent = 'ID gerado! Compartilhe.';
            },
            onCopyRoomId: () => {
                if (uiElements.roomInput.value) {
                    navigator.clipboard.writeText(uiElements.roomInput.value);
                    uiElements.statusDisplay.textContent = 'ID copiado!';
                }
            },
            onMultiplayerStart: () => {
                gameConfig.isOffline = false;
                gameConfig.playerName = uiElements.playerNameInput.value.trim() || 'Jogador';
                if (!gameConfig.playerName) {
                    uiElements.statusDisplay.textContent = 'Por favor, digite seu nome.';
                    return;
                }
                gameConfig.roomId = uiElements.roomInput.value.trim();
                if (!gameConfig.roomId) {
                    uiElements.statusDisplay.textContent = 'Por favor, insira ou gere um ID de sala.';
                    return;
                }
                showScreen('selectionScreen');
                updateMoneyDisplay();
            },
            onOfflineStart: () => {
                gameConfig.isOffline = true;
                gameConfig.playerName = uiElements.playerNameInput.value.trim() || 'Jogador';
                if (!gameConfig.playerName) {
                    uiElements.statusDisplay.textContent = 'Por favor, digite seu nome.';
                    return;
                }
                gameConfig.opponentName = 'CPU'; // Default name for CPU
                showScreen('selectionScreen');
                updateMoneyDisplay();
            },
            onRaceStart: () => {
                soundManager.audioContext.resume().then(() => {
                    console.log('AudioContext resumed!');
                    if (!gameConfig.isOffline) {
                        connectToServer();
                        showScreen('loadingOverlay');
                        uiElements.loadingText.textContent = 'Conectando ao servidor...';
                    } else {
                        setupGameScene();
                        showScreen('gameScreen');
                        startGame();
                    }
                }).catch(e => console.error('Could not resume AudioContext:', e));
            },
            onBuyUpgrade: (upgradeType) => {
                let currentLevel = gameConfig.upgrades[upgradeType];
                let cost = getUpgradeCost(upgradeType, currentLevel);
                const maxLevel = 3;

                if (currentLevel < maxLevel && gameConfig.money >= cost) {
                    gameConfig.money -= cost;
                    gameConfig.upgrades[upgradeType]++;
                    updateMoneyDisplay();
                } else if (currentLevel >= maxLevel) {
                    console.log(`Upgrade ${upgradeType} já está no nível máximo.`);
                } else {
                    console.log('Dinheiro insuficiente!');
                }
            },
            onBetIncrease: () => {
                const maxBet = Math.floor(gameConfig.money * 0.5); // Max 50% of current money
                if (gameConfig.betAmount < maxBet) {
                    gameConfig.betAmount = Math.min(maxBet, gameConfig.betAmount + 50); // Increment by 50
                    updateBetValue(gameConfig.betAmount);
                }
            },
            onBetDecrease: () => {
                if (gameConfig.betAmount > 0) {
                    gameConfig.betAmount = Math.max(0, gameConfig.betAmount - 50);
                    updateBetValue(gameConfig.betAmount);
                }
            },
            onCarSelected: (carId) => {
                gameConfig.selectedCarId = carId;
            },
            onTrackSelected: (trackId) => {
                gameConfig.selectedTrackId = trackId;
            },
            onRematch: () => {
                if (!gameConfig.isOffline && dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'rematch_request', playerId: gameConfig.playerId }));
                    uiElements.loadingText.textContent = 'Aguardando rematch do oponente...';
                    showScreen('loadingOverlay');
                } else if (gameConfig.isOffline) {
                    restartGame();
                    showScreen('gameScreen');
                }
            },
            onExitGame: () => {
                closeConnections();
                gameConfig.status = 'waiting';
                showScreen('startScreen');
                uiElements.statusDisplay.textContent = 'Pronto para jogar novamente';
                gameConfig.playerId = null;
                gameConfig.roomId = null;
                gameConfig.isOffline = false;
                gameConfig.betAmount = 0;
                updateBetValue(0);
                localCar = null;
                remoteCar = null;
                players = {};
                finishTimes = {};
                // If you want to persist money/upgrades, load from localStorage here instead of reset
                // gameConfig.money = 300; 
                // gameConfig.upgrades = { torque: 0, speed: 0, gears: 0 };
            },
            // Mobile Control Callbacks
            onAccelerateStart: () => { keys['accelerate'] = true; uiElements.accelerateBtn.classList.add('active'); },
            onAccelerateEnd: () => { keys['accelerate'] = false; uiElements.accelerateBtn.classList.remove('active'); },
            onBrakeStart: () => { keys['brake'] = true; uiElements.brakeBtn.classList.add('active'); },
            onBrakeEnd: () => { keys['brake'] = false; uiElements.brakeBtn.classList.remove('active'); },
            onGearUp: () => { shiftGearUp(); },
            onGearDown: () => { shiftGearDown(); },
            onTurnLeftStart: () => { keys['turnLeft'] = true; uiElements.turnLeftBtn.classList.add('active'); },
            onTurnLeftEnd: () => { keys['turnLeft'] = false; uiElements.turnLeftBtn.classList.remove('active'); },
            onTurnRightStart: () => { keys['turnRight'] = true; uiElements.turnRightBtn.classList.add('active'); },
            onTurnRightEnd: () => { keys['turnRight'] = false; uiElements.turnRightBtn.classList.remove('active'); },
        };

        // --- Core Game Functions ---
        async function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, -50);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -200;
            directionalLight.shadow.camera.right = 200;
            directionalLight.shadow.camera.top = 200;
            directionalLight.shadow.camera.bottom = -200;
            scene.add(directionalLight);

            await soundManager.init();

            setupControls();
            animate();

            window.addEventListener('resize', onWindowResize);
            
            // Initialize UI elements and event listeners
            initUI();
        }

        function setupGameScene() {
            // Clear previous scene elements
            if (localCar && localCar.group) scene.remove(localCar.group);
            if (remoteCar && remoteCar.group) scene.remove(remoteCar.group);
            if (currentTrackModel) scene.remove(currentTrackModel);

            // Create selected car models
            const selectedCarDef = carFactory.getCarById(gameConfig.selectedCarId);
            if (!selectedCarDef) {
                console.error('Selected car definition not found:', gameConfig.selectedCarId);
                return;
            }
            const localCarModel = selectedCarDef.createModel(selectedCarDef.color);
            localCar = {
                group: localCarModel.group,
                wheels: localCarModel.wheels,
                data: {
                    position: new THREE.Vector3().copy(trackFactory.getTrackById(gameConfig.selectedTrackId).startPosition),
                    rotation: 0,
                    targetRotation: 0,
                    accelerationFactor: selectedCarDef.accelerationFactor,
                    maxSpeedBase: selectedCarDef.maxSpeedBase,
                    torqueMultiplierBase: selectedCarDef.torqueMultiplierBase,
                    handlingFactor: selectedCarDef.handlingFactor,
                    color: selectedCarDef.color,
                    name: gameConfig.playerName,
                    currentLap: 0,
                    lastCheckpoint: 0
                },
                nameTag: createNameTagSprite(gameConfig.playerName, selectedCarDef.color)
            };
            localCar.group.add(localCar.nameTag);
            scene.add(localCar.group);
            localCar.group.position.copy(localCar.data.position);
            localCar.data.rotation = 0;
            localCar.group.rotation.y = localCar.data.rotation;
            
            uiElements.playerNameHud.textContent = gameConfig.playerName;

            if (!gameConfig.isOffline) {
                const remoteCarModel = selectedCarDef.createModel(); // Opponent uses same car type for now
                const opponentColor = new THREE.Color(selectedCarDef.color).offsetHSL(0.1, 0, 0).getHex();
                remoteCarModel.group.traverse((node) => {
                    if (node.isMesh && node.material instanceof THREE.MeshStandardMaterial) {
                        node.material.color.set(opponentColor);
                    }
                });

                remoteCar = {
                    group: remoteCarModel.group,
                    wheels: remoteCarModel.wheels,
                    data: {
                        position: new THREE.Vector3().copy(trackFactory.getTrackById(gameConfig.selectedTrackId).startPosition),
                        rotation: 0,
                        name: gameConfig.opponentName,
                        color: opponentColor,
                        currentLap: 0
                    },
                    nameTag: createNameTagSprite(gameConfig.opponentName, opponentColor)
                };
                remoteCar.group.add(remoteCar.nameTag);
                scene.add(remoteCar.group);
                remoteCar.group.position.copy(localCar.data.position).add(new THREE.Vector3(0, 0, -5));
                remoteCar.data.position.copy(remoteCar.group.position);
            } else {
                remoteCar = null;
            }

            const selectedTrackDef = trackFactory.getTrackById(gameConfig.selectedTrackId);
            if (!selectedTrackDef) {
                console.error('Selected track definition not found:', gameConfig.selectedTrackId);
                return;
            }
            currentTrackModel = selectedTrackDef.createModel();
            scene.add(currentTrackModel);

            players[gameConfig.playerId] = {
                name: gameConfig.playerName,
                id: gameConfig.playerId,
                x: localCar.data.position.x,
                z: localCar.data.position.z,
                rotation: localCar.data.rotation,
                lap: 0,
                lastCheckpoint: 0,
                finishTime: null
            };

            if (!gameConfig.isOffline && remoteCar) {
                const opponentPId = gameConfig.playerId === 0 ? 1 : 0;
                players[opponentPId] = {
                    name: gameConfig.opponentName,
                    id: opponentPId,
                    x: remoteCar.data.position.x,
                    z: remoteCar.data.position.z,
                    rotation: remoteCar.data.rotation,
                    lap: 0,
                    lastCheckpoint: 0,
                    finishTime: null
                };
            }
        }

        function setupControls() {
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') keys['accelerate'] = true;
                if (e.code === 'KeyS') keys['brake'] = true; // S sets brake
                if (e.code === 'KeyA') keys['turnLeft'] = true;
                if (e.code === 'KeyD') keys['turnRight'] = true;
                if (e.code === 'KeyW') shiftGearUp();
                if (e.code === 'KeyQ') shiftGearDown(); // Q for shifting down
            });

            window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') keys['accelerate'] = false;
                if (e.code === 'KeyS') keys['brake'] = false;
                if (e.code === 'KeyA') keys['turnLeft'] = false;
                if (e.code === 'KeyD') keys['turnRight'] = false;
            });
        }

        function updateControlState() {
            gameConfig.accelerationInput = 0;
            if (keys['accelerate']) {
                gameConfig.accelerationInput = 1; // Acelerar
            }
            if (keys['brake']) {
                gameConfig.accelerationInput = -0.5; // Frear / Ré
            }

            gameConfig.steeringInput = 0;
            if (keys['turnLeft']) {
                gameConfig.steeringInput = 1;
            }
            if (keys['turnRight']) {
                gameConfig.steeringInput = -1;
            }
        }

        // --- WebRTC Connection Functions ---
        function connectToServer() {
            uiElements.statusDisplay.textContent = 'Conectando ao servidor...';
            
            ws = new WebSocket(SERVER_URL);

            ws.onopen = () => {
                uiElements.statusDisplay.textContent = 'Aguardando oponente...';
                ws.send(JSON.stringify({ 
                    type: 'join', 
                    roomId: gameConfig.roomId,
                    playerName: gameConfig.playerName,
                    carId: gameConfig.selectedCarId,
                    trackId: gameConfig.selectedTrackId
                }));
            };

            ws.onerror = (error) => {
                uiElements.statusDisplay.textContent = 'Erro na conexão. Tente novamente.';
                showScreen('selectionScreen');
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                uiElements.statusDisplay.textContent = 'Conexão fechada.';
                if (gameConfig.status === 'playing' || gameConfig.status === 'finished') {
                     showEndGameScreen(`Oponente desconectou.`, []);
                } else {
                    showScreen('selectionScreen');
                }
                closeConnections();
                gameConfig.status = 'waiting';
            };

            ws.onmessage = async (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'start_multiplayer') {
                        gameConfig.playerId = data.playerId;
                        gameConfig.opponentName = data.opponentName;
                        gameConfig.selectedCarId = data.localCarId;
                        gameConfig.selectedTrackId = data.localTrackId;
                        
                        uiElements.statusDisplay.textContent = `Conectado! Você é o Jogador ${gameConfig.playerId + 1}`;
                        initPeerConnection();
                        if (gameConfig.playerId === 0) {
                            dataChannel = peerConnection.createDataChannel('gameData');
                            setupDataChannel(true);
                            const offer = await peerConnection.createOffer();
                            await peerConnection.setLocalDescription(offer);
                            ws.send(JSON.stringify({ type: 'offer', sdp: offer, roomId: gameConfig.roomId }));
                        }
                        setupGameScene();
                    } else if (data.type === 'offer') {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        ws.send(JSON.stringify({ type: 'answer', sdp: answer, roomId: gameConfig.roomId }));
                    } else if (data.type === 'answer') {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    } else if (data.type === 'ice') {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    } else if (data.type === 'error') {
                        uiElements.statusDisplay.textContent = `Erro: ${data.message}`;
                        showScreen('selectionScreen');
                    }
                } catch (error) {
                    console.error('Error processing message from WebSocket:', error);
                    uiElements.statusDisplay.textContent = 'Erro no processamento.';
                    showScreen('selectionScreen');
                }
            };
        }

        function initPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ type: 'ice', candidate: event.candidate, roomId: gameConfig.roomId }));
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                uiElements.statusDisplay.textContent = `Estado da Conexão: ${state}`;
                if (state === 'failed' || state === 'disconnected') {
                    uiElements.statusDisplay.textContent = 'Conexão P2P perdida. Tentando reconectar...';
                } else if (state === 'connected') {
                    uiElements.statusDisplay.textContent = 'Conexão P2P estabelecida!';
                    if (dataChannel && dataChannel.readyState === 'open') {
                         startGame();
                    }
                }
            };

            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel(false);
            };
        }

        function setupDataChannel(isInitiator) {
            dataChannel.onopen = () => {
                statusDisplay.textContent = 'Canal de dados aberto. Iniciando jogo...';
                showScreen('gameScreen');
                startGame();

                const carDefinition = carFactory.getCarById(gameConfig.selectedCarId);
                dataChannel.send(JSON.stringify({ 
                    type: 'player_info', 
                    name: gameConfig.playerName, 
                    color: carDefinition ? carDefinition.color : 0x3366ff 
                }));
            };

            dataChannel.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const opponentId = gameConfig.playerId === 0 ? 1 : 0;

                    if (data.type === 'move') {
                        if (remoteCar && players[opponentId]) {
                            remoteCar.data.position.set(data.x, remoteCar.data.position.y, data.z);
                            remoteCar.data.rotation = data.rotation;
                            remoteCar.group.position.copy(remoteCar.data.position);
                            remoteCar.group.rotation.y = remoteCar.data.rotation;

                            const wheelRotationSpeed = data.speed * deltaTime * 0.1;
                            remoteCar.wheels.forEach(wheel => {
                                wheel.rotation.x += wheelRotationSpeed;
                            });
                        }
                        players[opponentId].x = data.x;
                        players[opponentId].z = data.z;
                        players[opponentId].rotation = data.rotation;
                        players[opponentId].lastCheckpoint = data.lastCheckpoint;
                    } else if (data.type === 'lap_update') {
                        if (players[opponentId]) {
                            players[opponentId].lap = data.lap;
                            players[opponentId].lastCheckpoint = data.lastCheckpoint;
                        }
                    } else if (data.type === 'player_info') {
                        gameConfig.opponentName = data.name;
                        remoteCar.data.name = data.name;
                        remoteCar.nameTag.material.map = createNameTagCanvas(data.name, data.color);
                        remoteCar.nameTag.material.map.needsUpdate = true;
                        remoteCar.group.traverse((node) => {
                            if (node.isMesh && node.material instanceof THREE.MeshStandardMaterial) {
                                // Apply color only to the main body, not wheels or other parts that might be boxes
                                if (node.geometry && node.geometry.parameters && node.geometry.parameters.width && node.geometry.parameters.height && node.geometry.parameters.depth) {
                                    if (node.geometry.parameters.width > 2 && node.geometry.parameters.height > 0.5 && node.geometry.parameters.depth > 2) {
                                        node.material.color.set(data.color);
                                    }
                                }
                            }
                        });
                        console.log(`Opponent is: ${data.name} with car color ${data.color.toString(16)}`);
                    } else if (data.type === 'race_finished') {
                        if (!finishTimes[opponentId]) {
                            finishTimes[opponentId] = data.finishTime;
                            players[opponentId].finishTime = data.finishTime;
                            checkRaceCompletion();
                        }
                    } else if (data.type === 'rematch_request') {
                        dataChannel.send(JSON.stringify({ type: 'rematch_accepted', playerId: gameConfig.playerId }));
                        restartGame();
                        showScreen('gameScreen');
                        uiElements.statusDisplay.textContent = 'Rematch aceito. Iniciando...';
                    } else if (data.type === 'rematch_accepted') {
                        restartGame();
                        showScreen('gameScreen');
                        uiElements.statusDisplay.textContent = 'Rematch aceito pelo oponente. Iniciando...';
                    }
                } catch (error) {
                    console.error('DataChannel message error:', error, event.data);
                }
            };

            dataChannel.onclose = () => {
                uiElements.statusDisplay.textContent = 'Canal de dados fechado.';
                if (gameConfig.status === 'playing' || gameConfig.status === 'finished') {
                    showEndGameScreen(`Oponente desconectou.`, [
                        { name: gameConfig.playerName, time: players[gameConfig.playerId]?.finishTime || (Date.now() - startTime) },
                        { name: gameConfig.opponentName, time: players[gameConfig.playerId === 0 ? 1 : 0]?.finishTime || (Date.now() - startTime) }
                    ]);
                }
                closeConnections();
            };

            dataChannel.onerror = (error) => {
                console.error('DataChannel error:', error);
                uiElements.statusDisplay.textContent = 'Erro no canal de dados.';
            };
        }

        // --- Game Logic Functions ---
        function startGame() {
            gameConfig.status = 'playing';
            startTime = null; // Set to null initially, will be set on first physics update for accurate timing
            finishTimes = {};

            gameConfig.speed = 0;
            gameConfig.gear = 'N';
            gameConfig.accelerationInput = 0;
            gameConfig.steeringInput = 0;
            localCar.data.targetRotation = 0;
            localCar.data.currentLap = 0;
            localCar.data.lastCheckpoint = 0;

            localCar.group.position.copy(trackFactory.getTrackById(gameConfig.selectedTrackId).startPosition);
            localCar.group.rotation.y = 0;

            if (!gameConfig.isOffline && remoteCar) {
                remoteCar.group.position.copy(localCar.data.position).add(new THREE.Vector3(0, 0, -5));
                remoteCar.group.rotation.y = 0;
                
                remoteCar.data.position.copy(remoteCar.group.position);
                remoteCar.data.rotation = 0;
                remoteCar.data.currentLap = 0;
                remoteCar.data.lastCheckpoint = 0;

                players[gameConfig.playerId === 0 ? 1 : 0].x = remoteCar.data.position.x;
                players[gameConfig.playerId === 0 ? 1 : 0].z = remoteCar.data.position.z;
                players[gameConfig.playerId === 0 ? 1 : 0].rotation = remoteCar.data.rotation;
                players[gameConfig.playerId === 0 ? 1 : 0].lap = 0;
                players[gameConfig.playerId === 0 ? 1 : 0].lastCheckpoint = 0;
            }

            uiElements.loadingText.textContent = 'Preparando corrida...';
            showScreen('gameScreen');
            updateHUD(0, 'N', 0, 3, 1, 0);
            soundManager.startEngineSound();
        }

        function restartGame() {
            gameConfig.status = 'playing';
            startTime = null; // Set to null initially
            finishTimes = {};

            gameConfig.speed = 0;
            gameConfig.gear = 'N';
            gameConfig.accelerationInput = 0;
            gameConfig.steeringInput = 0;
            localCar.data.targetRotation = 0;
            localCar.data.currentLap = 0;
            localCar.data.lastCheckpoint = 0;

            localCar.group.position.copy(trackFactory.getTrackById(gameConfig.selectedTrackId).startPosition);
            localCar.group.rotation.y = 0;

            if (!gameConfig.isOffline && remoteCar) {
                remoteCar.group.position.copy(localCar.data.position).add(new THREE.Vector3(0, 0, -5));
                remoteCar.group.rotation.y = 0;
                
                remoteCar.data.position.copy(remoteCar.group.position);
                remoteCar.data.rotation = 0;
                remoteCar.data.currentLap = 0;
                remoteCar.data.lastCheckpoint = 0;

                players[gameConfig.playerId === 0 ? 1 : 0].x = remoteCar.data.position.x;
                players[gameConfig.playerId === 0 ? 1 : 0].z = remoteCar.data.position.z;
                players[gameConfig.playerId === 0 ? 1 : 0].rotation = remoteCar.data.rotation;
                players[gameConfig.playerId === 0 ? 1 : 0].lap = 0;
                players[gameConfig.playerId === 0 ? 1 : 0].lastCheckpoint = 0;
            }

            soundManager.startEngineSound();
            updateHUD(0, 'N', 0, 3, 1, 0);
            uiElements.statusDisplay.textContent = 'Corrida reiniciada!';
            showScreen('gameScreen');
        }

        function updatePhysics() {
            if (startTime === null) { // Set start time on first update
                startTime = Date.now();
            }

            const carStats = localCar.data;
            const currentGearSetting = gearSettings[gameConfig.gear];
            const speedKmh = gameConfig.speed; // Current speed in km/h

            const upgradeTorqueFactor = 1 + (gameConfig.upgrades.torque * 0.2);
            const upgradeSpeedFactor = 1 + (gameConfig.upgrades.speed * 0.15);
            const upgradeGearFactor = 1 + (gameConfig.upgrades.gears * 0.25);

            let rpm = 0;
            if (currentGearSetting.name !== 'N') {
                // Calculate RPM based on current speed and gear's max speed
                // Max RPM is 8000 for simplicity
                const effectiveMaxSpeedForGear = currentGearSetting.maxSpeed * upgradeSpeedFactor;
                rpm = (Math.abs(speedKmh) / effectiveMaxSpeedForGear) * 8000;
                rpm = Math.min(8000, Math.max(0, rpm)); // Ensure RPM is between 0 and 8000
            }
            gameConfig.currentTorque = rpm; // Using rpm for torque display

            // Calculate torque efficiency based on speed within optimal range
            let torqueEfficiency = 0;
            if (gameConfig.gear !== 'N') {
                const optimalMin = currentGearSetting.optimalMin * upgradeGearFactor;
                const optimalMax = currentGearSetting.optimalMax * upgradeGearFactor;

                if (Math.abs(speedKmh) >= optimalMin && Math.abs(speedKmh) <= optimalMax) {
                    torqueEfficiency = currentGearSetting.torqueMultiplier;
                } else {
                    const distanceToOptimal = Math.min(
                        Math.abs(Math.abs(speedKmh) - optimalMin),
                        Math.abs(Math.abs(speedKmh) - optimalMax)
                    );
                    // Reduce torque efficiency outside optimal range
                    torqueEfficiency = currentGearSetting.torqueMultiplier * Math.max(0.1, 1 - (distanceToOptimal / 50));
                }
            } else { // Neutral gear has very low torque efficiency
                torqueEfficiency = currentGearSetting.torqueMultiplier; // This is 0.1 for Neutral
            }
            torqueEfficiency *= upgradeTorqueFactor; // Apply global torque upgrade

            // Determine effective acceleration input based on gear
            let effectiveAccelerationInput = gameConfig.accelerationInput;
            if (gameConfig.gear === 'R') {
                // In reverse gear, only negative input (brake/reverse) causes acceleration (reverse)
                // Positive input (accelerate) acts as a very light brake/neutral
                if (effectiveAccelerationInput > 0) {
                    effectiveAccelerationInput = -0.05; // Light brake if trying to accelerate forward in reverse
                }
            } else if (gameConfig.gear === 'N') {
                // In neutral, movement is minimal regardless of input
                effectiveAccelerationInput *= 0.1; 
            } else { // Forward gears (1-5)
                // In forward gears, negative input acts as brake, positive as acceleration.
                // No change needed to effectiveAccelerationInput here for its sign.
            }

            let accelerationForce = effectiveAccelerationInput * torqueEfficiency * carStats.accelerationFactor;

            // Apply friction/resistance based on track zone
            let frictionMultiplier = 1.0;
            const selectedTrack = trackFactory.getTrackById(gameConfig.selectedTrackId);
            if (selectedTrack && selectedTrack.frictionZones) {
                const carPos2D = new THREE.Vector2(localCar.data.position.x, localCar.data.position.z);
                selectedTrack.frictionZones.forEach(zone => {
                    let isInZone = false;
                    
                    if (zone.type === 'circular_band') {
                        const distance = carPos2D.distanceTo(new THREE.Vector2(0,0));
                        if (distance > zone.innerRadius && distance < zone.outerRadius) {
                            isInZone = true;
                        }
                    } else if (zone.type === 'circle') {
                        const distance = carPos2D.distanceTo(new THREE.Vector2(0,0));
                        if (distance < zone.radius) {
                            isInZone = true;
                        }
                    } else if (zone.type === 'curve_proximity') {
                        const trackCurve = zone.curve;
                        const resolution = 100;
                        let minDistanceSq = Infinity;

                        for (let i = 0; i <= resolution; i++) {
                            const pointOnCurve = trackCurve.getPointAt(i / resolution);
                            const distSq = localCar.data.position.distanceToSquared(pointOnCurve);
                            if (distSq < minDistanceSq) {
                                minDistanceSq = distSq;
                            }
                        }
                        
                        if (Math.sqrt(minDistanceSq) > (zone.roadWidth / 2) + 2) { // 2 meters tolerance from road edge
                            isInZone = true;
                        }
                    }
                    
                    if (isInZone) {
                        frictionMultiplier = Math.min(frictionMultiplier, zone.frictionMultiplier); // Take the lowest friction
                        if (Math.abs(speedKmh) > 20 && frictionMultiplier < 1.0 && Math.random() < 0.1) {
                            soundManager.playSkid();
                        }
                    }
                });
            }

            // Apply drag (always opposes motion)
            const drag = 0.005 * speedKmh * Math.abs(speedKmh); // Quadratic drag
            accelerationForce -= Math.sign(speedKmh) * drag;

            // Update speed
            gameConfig.speed += accelerationForce * deltaTime * 60; // Multiply by 60 for km/h scaling

            // Apply global friction decay
            gameConfig.speed *= (1 - (0.01 * deltaTime * frictionMultiplier));

            // Apply speed limits based on gear and effective input direction
            if (gameConfig.gear === 'R') {
                // In reverse gear, speed is capped at -maxSpeed and cannot go positive
                gameConfig.speed = Math.max(-currentGearSetting.maxSpeed, Math.min(0, gameConfig.speed));
            } else if (gameConfig.gear === 'N') {
                // In neutral, speed should decay towards zero, with very little acceleration
                if (Math.abs(gameConfig.speed) < 0.5) gameConfig.speed = 0; // Snap to zero if very slow
            } else { // Forward gears (1-5)
                // In forward gears, speed cannot go negative, and is capped at maxSpeed
                gameConfig.speed = Math.max(0, Math.min(currentGearSetting.maxSpeed * upgradeSpeedFactor, gameConfig.speed));
            }

            // Update steering
            const steeringFactor = carStats.handlingFactor * (1 + gameConfig.upgrades.gears * 0.1);
            let steerAmount = gameConfig.steeringInput * deltaTime * 1.5 * steeringFactor;
            
            // Reduce steering at very low speeds
            if (Math.abs(speedKmh) < 5) {
                steerAmount *= (Math.abs(speedKmh) / 5);
            }
            // Apply steering direction based on car's current speed direction
            if (Math.abs(speedKmh) > 0.1) { // Only steer if car is moving
                localCar.data.targetRotation -= steerAmount * Math.sign(speedKmh); // Steer correctly for reverse
            }

            // Smooth rotation
            localCar.data.rotation += (localCar.data.targetRotation - localCar.data.rotation) * 0.1;

            // Update position
            const direction = new THREE.Vector3(
                Math.sin(localCar.data.rotation),
                0,
                Math.cos(localCar.data.rotation)
            );
            localCar.data.position.add(direction.multiplyScalar(gameConfig.speed * deltaTime));

            // Sync 3D model to physics data
            localCar.group.position.copy(localCar.data.position);
            localCar.group.rotation.y = localCar.data.rotation;

            // Rotate wheels based on speed
            const wheelRotationSpeed = gameConfig.speed * deltaTime * 0.1;
            localCar.wheels.forEach(wheel => {
                wheel.rotation.x += wheelRotationSpeed;
            });

            // Update player data for multiplayer sync
            players[gameConfig.playerId].x = localCar.data.position.x;
            players[gameConfig.playerId].z = localCar.data.position.z;
            players[gameConfig.playerId].rotation = localCar.data.rotation;
            players[gameConfig.playerId].speed = gameConfig.speed;

            checkLapCompletion();
            updateCamera();
            updateHUD(gameConfig.speed, gameConfig.gear, localCar.data.currentLap, 3, calculatePosition(), gameConfig.currentTorque);
            soundManager.updateEngineSound(gameConfig.speed, gameConfig.gear, carStats.maxSpeedBase, gameConfig.currentTorque);

            const now = Date.now();
            if (!gameConfig.isOffline && dataChannel && dataChannel.readyState === 'open' && now - lastMoveSentTime > 50) {
                dataChannel.send(JSON.stringify({ 
                    type: 'move', 
                    x: localCar.data.position.x,
                    z: localCar.data.position.z,
                    rotation: localCar.data.rotation,
                    speed: gameConfig.speed,
                    lastCheckpoint: localCar.data.lastCheckpoint
                }));
                lastMoveSentTime = now;
            }
            if (gameConfig.isOffline && remoteCar) {
                updateCpuOpponent();
            }
        }

        function updateCpuOpponent() {
            const trackDef = trackFactory.getTrackById(gameConfig.selectedTrackId);
            if (!trackDef || !trackDef.checkpoints || trackDef.checkpoints.length === 0) return;

            const opponentId = gameConfig.playerId === 0 ? 1 : 0;
            const cpuPlayer = players[opponentId];
            if (!cpuPlayer) return;

            const cpuSpeed = 50 + Math.random() * 20; // Basic CPU speed
            
            const targetCheckpoint = trackDef.checkpoints[cpuPlayer.lastCheckpoint];
            if (targetCheckpoint) {
                const targetPos = targetCheckpoint.position;
                const currentPos = new THREE.Vector3(cpuPlayer.x, 0, cpuPlayer.z);
                const directionToTarget = new THREE.Vector3().subVectors(targetPos, currentPos).normalize();

                const currentDirection = new THREE.Vector3(Math.sin(cpuPlayer.rotation), 0, Math.cos(cpuPlayer.rotation));
                const angleDiff = Math.atan2(currentDirection.x * directionToTarget.z - currentDirection.z * directionToTarget.x, currentDirection.x * directionToTarget.x + currentDirection.z * directionToTarget.z);
                
                cpuPlayer.rotation += angleDiff * 0.05; // Steer towards checkpoint

                const moveDirection = new THREE.Vector3(
                    Math.sin(cpuPlayer.rotation),
                    0,
                    Math.cos(cpuPlayer.rotation)
                );
                currentPos.add(moveDirection.multiplyScalar(cpuSpeed * deltaTime));
                
                cpuPlayer.x = currentPos.x;
                cpuPlayer.z = currentPos.z;

                remoteCar.group.position.set(cpuPlayer.x, remoteCar.data.position.y, cpuPlayer.z);
                remoteCar.group.rotation.y = cpuPlayer.rotation;

                const wheelRotationSpeed = cpuSpeed * deltaTime * 0.1;
                remoteCar.wheels.forEach(wheel => {
                    wheel.rotation.x += wheelRotationSpeed;
                });

                // Check if CPU reached checkpoint
                if (currentPos.distanceTo(targetPos) < targetCheckpoint.radius) {
                    cpuPlayer.lastCheckpoint = targetCheckpoint.nextCheckpointIndex;
                    // If CPU passes start/finish line AND the next checkpoint is the first one again
                    if (targetCheckpoint.isStartFinish && cpuPlayer.lastCheckpoint === trackDef.checkpoints[0].nextCheckpointIndex) {
                        cpuPlayer.lap++;
                        // Ensure lap count doesn't exceed total for race completion
                        cpuPlayer.lap = Math.min(3, cpuPlayer.lap); 
                        if (cpuPlayer.lap >= 3 && cpuPlayer.finishTime === null) {
                            // CPU finishes with a slightly randomized time around player's expected time
                            cpuPlayer.finishTime = (Date.now() - startTime) + (Math.random() * 5000 - 2500); // +/- 2.5 seconds
                            checkRaceCompletion();
                        }
                    }
                }
            }
        }

        function checkLapCompletion() {
            const trackDef = trackFactory.getTrackById(gameConfig.selectedTrackId);
            if (!trackDef || !trackDef.checkpoints || trackDef.checkpoints.length === 0) return;

            const currentCheckpointTarget = trackDef.checkpoints[localCar.data.lastCheckpoint];
            const carPosition = localCar.data.position;

            if (carPosition.distanceTo(currentCheckpointTarget.position) < currentCheckpointTarget.radius) {
                localCar.data.lastCheckpoint = currentCheckpointTarget.nextCheckpointIndex; 

                if (currentCheckpointTarget.isStartFinish && localCar.data.lastCheckpoint === trackDef.checkpoints[0].nextCheckpointIndex) { 
                     localCar.data.currentLap++;
                     players[gameConfig.playerId].lap = localCar.data.currentLap;

                     if (!gameConfig.isOffline && dataChannel && dataChannel.readyState === 'open') {
                         dataChannel.send(JSON.stringify({ 
                             type: 'lap_update', 
                             lap: localCar.data.currentLap,
                             lastCheckpoint: localCar.data.lastCheckpoint
                         }));
                     }
                     
                     if (localCar.data.currentLap >= 3 && players[gameConfig.playerId].finishTime === null) {
                         players[gameConfig.playerId].finishTime = Date.now() - startTime;
                         checkRaceCompletion();
                     }
                 }
            }
        }

        function checkRaceCompletion() {
            const totalPlayers = gameConfig.isOffline ? 1 : 2;
            let finishedPlayers = 0;
            Object.values(players).forEach(p => {
                if (p.finishTime !== null) {
                    finishedPlayers++;
                }
            });

            if (finishedPlayers === totalPlayers) {
                gameConfig.status = 'finished';
                soundManager.stopEngineSound();

                const sortedResults = Object.values(players).sort((a, b) => a.finishTime - b.finishTime);
                const localPlayerResult = sortedResults.find(p => p.id === gameConfig.playerId);

                let message = '';
                if (localPlayerResult && localPlayerResult.finishTime === sortedResults[0].finishTime) {
                    message = 'VOCÊ VENCEU!';
                    if (gameConfig.betAmount > 0) {
                        gameConfig.money += gameConfig.betAmount; // Win bet amount
                        updateMoneyDisplay();
                    }
                } else {
                    message = 'VOCÊ PERDEU!';
                    // Only deduct money if it was a multiplayer race and there was a bet
                    if (!gameConfig.isOffline && gameConfig.betAmount > 0) {
                        gameConfig.money -= gameConfig.betAmount; // Lose bet amount
                        updateMoneyDisplay();
                    }
                }
                showEndGameScreen(message, sortedResults);

                if (!gameConfig.isOffline && dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ 
                        type: 'race_finished', 
                        playerId: gameConfig.playerId,
                        finishTime: players[gameConfig.playerId].finishTime
                    }));
                }
            }
        }

        function updateCamera() {
            if (!localCar) return;

            const carPosition = localCar.group.position.clone();
            const offsetDistance = 25;
            const cameraHeight = 15;

            const cameraOffset = new THREE.Vector3(
                Math.sin(localCar.data.rotation) * offsetDistance,
                cameraHeight,
                Math.cos(localCar.data.rotation) * offsetDistance
            );
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI); // Rotate 180 degrees to be behind car

            camera.position.copy(carPosition).add(cameraOffset);
            camera.lookAt(carPosition.x, carPosition.y + 2, carPosition.z);
        }

        function calculatePosition() {
            // In offline mode, you are always 1st (no other real player)
            if (gameConfig.isOffline) return 1; 

            const localPlayer = players[gameConfig.playerId];
            const opponentPlayer = players[gameConfig.playerId === 0 ? 1 : 0];

            if (!localPlayer || !opponentPlayer) return 1;

            // Simple position calculation: first by lap, then by checkpoint, then by distance to next checkpoint
            if (localPlayer.lap > opponentPlayer.lap) return 1;
            if (localPlayer.lap < opponentPlayer.lap) return 2;

            // If laps are equal, check checkpoints
            if (localPlayer.lastCheckpoint > opponentPlayer.lastCheckpoint) return 1;
            if (localPlayer.lastCheckpoint < opponentPlayer.lastCheckpoint) return 2;

            // If laps and checkpoints are equal, check distance to next checkpoint
            const trackDef = trackFactory.getTrackById(gameConfig.selectedTrackId);
            if (trackDef && trackDef.checkpoints && trackDef.checkpoints.length > 0) {
                const nextLocalCheckpoint = trackDef.checkpoints[localPlayer.lastCheckpoint];
                const nextOpponentCheckpoint = trackDef.checkpoints[opponentPlayer.lastCheckpoint];

                if (nextLocalCheckpoint && nextOpponentCheckpoint) {
                    const distLocal = localCar.data.position.distanceTo(nextLocalCheckpoint.position);
                    const distOpponent = remoteCar.data.position.distanceTo(nextOpponentCheckpoint.position);

                    if (distLocal < distOpponent) return 1;
                    if (distLocal > distOpponent) return 2;
                }
            }

            return 1; // Default to 1st if all else is equal
        }

        function shiftGearUp() {
            const gears = ['R', 'N', '1', '2', '3', '4', '5']; // Define order of gears
            const currentIndex = gears.indexOf(gameConfig.gear);
            if (currentIndex < gears.length - 1) {
                gameConfig.gear = gears[currentIndex + 1];
                soundManager.playGearShift();
            }
        }

        function shiftGearDown() {
            const gears = ['R', 'N', '1', '2', '3', '4', '5']; // Define order of gears
            const currentIndex = gears.indexOf(gameConfig.gear);
            if (currentIndex > 0) {
                gameConfig.gear = gears[currentIndex - 1];
                soundManager.playGearShift();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function showEndGameScreen(message, results) {
            // Ensure results are properly sorted for display
            const formattedResults = results.map(p => ({
                name: p.name,
                time: p.finishTime !== null ? p.finishTime : (Date.now() - startTime) // Fallback for opponent not finished
            }));
            formattedResults.sort((a, b) => a.time - b.time);

            uiElements.endGameMessage.textContent = message;
            let resultsHTML = '<h3>Resultados:</h3>';
            formattedResults.forEach((result, index) => {
                resultsHTML += `<p>${index + 1}º ${result.name}: ${(result.time / 1000).toFixed(2)}s</p>`;
            });
            uiElements.raceResults.innerHTML = resultsHTML;
            showScreen('endGameScreen');
        }

        function closeConnections() {
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
            soundManager.stopEngineSound();
        }

        // --- Main Game Loop ---
        function animate() {
            requestAnimationFrame(animate);
            deltaTime = clock.getDelta(); // Time in seconds since last frame

            updateControlState(); // Only updates input state, does not modify physics

            if (gameConfig.status === 'playing') {
                updatePhysics(); // This is the single place physics is updated
            }

            renderer.render(scene, camera);
        }

        // Start the game on window load
        window.addEventListener('load', initGame);
    </script>
</body>
</html>